1
00:00:00,000 --> 00:00:03,000
The following content is provided under a Creative Commons license.

2
00:00:03,000 --> 00:00:10,000
Your support will help MIT OpenCourseware continue to offer high-quality educational resources for free.

3
00:00:10,000 --> 00:00:17,000
To make a donation, or view additional materials from hundreds of MIT courses, visit MIT OpenCourseware, at ocw.mit.edu .

4
00:00:17,000 --> 00:00:18,000
PROFESSOR: Good morning.

4
00:00:18,000 --> 00:00:19,000
Try it again.

4
00:00:19,000 --> 00:00:22,000
Good morning.

4
00:00:22,000 --> 00:00:25,000
STUDENTS: Good morning.

4
00:00:25,000 --> 00:00:27,000
PROFESSOR: Thank you.

4
00:00:27,000 --> 00:00:31,000
This is 6.00, also known as Introduction to Computer

4
00:00:31,000 --> 00:00:32,000
Science and Programming.

4
00:00:32,000 --> 00:00:39,000
My name is Eric Grimson, I have together Professor John Guttag over here, we're going to be lecturing the course this term.

5
00:00:39,000 --> 00:00:43,000
I want to give you a heads up; you're getting some serious firepower this term.

6
00:00:43,000 --> 00:00:51,000
John was department head for ten years, felt like a century, and in course six, I'm the current department head in course six.

7
00:00:51,000 --> 00:00:55,000
John's been lecturing for thirty years, roughly.

7
00:00:55,000 --> 00:00:59,000
All right, I'm the young guy, I've only been lecturing for twenty-five years.

8
00:00:59,000 --> 00:01:03,000
You can tell, I have less grey hair than he does.

8
00:01:03,000 --> 00:01:07,000
What I'm trying to say to you is, we take this course really seriously.

9
00:01:07,000 --> 00:01:08,000
We hope you do as well.

9
00:01:08,000 --> 00:01:16,000
But we think it's really important for the department to help everybody learn about computation, and that's what this course is about.

10
00:01:16,000 --> 00:01:26,000
What I want to do today is three things: I'm going to start-- actually, I shouldn't say start, I'm going to do a little bit of administrivia, the kinds of things you need to know about how we're going to run the course.

11
00:01:26,000 --> 00:01:41,000
I want to talk about the goal of the course, what it is you'll be able to do at the end of this course when you get through it, and then I want to begin talking about the concepts and tools of computational thinking, which is what we're primarily going to focus on here.

12
00:01:41,000 --> 00:01:50,000
We're going to try and help you learn how to think like a computer scientist, and we're going to begin talking about that towards the end of this lecture and of course throughout the rest of the lectures that carry on.

13
00:01:50,000 --> 00:01:52,000
Right, let's start with the goals.

13
00:01:52,000 --> 00:01:55,000
I'm going to give you goals in two levels.

13
00:01:55,000 --> 00:02:09,000
The strategic goals are the following: we want to help prepare freshmen and sophomores who are interested in majoring in course six to get an easy entry into the department, especially for those students who don't have a lot of prior programming experience.

14
00:02:09,000 --> 00:02:12,000
If you're in that category, don't panic, you're going to get it.

15
00:02:12,000 --> 00:02:20,000
We're going to help you ramp in and you'll certainly be able to start the course six curriculum and do just fine and still finish on target.

16
00:02:20,000 --> 00:02:37,000
We don't expect everybody to be a course six major, contrary to popular opinion, so for those are you not in that category, the second thing we want to do is we want to help students who don't plan to major in course six to feel justifiably confident in their ability to write and read small pieces of code.

17
00:02:37,000 --> 00:02:47,000
For all students, what we want to do is we want to give you an understanding of the role computation can and cannot play in tackling technical problems. So that you will

18
00:02:47,000 --> 00:02:54,000
come away with a sense of what you can do, what you can't do, and what kinds of things you should use to tackle complex problems.

19
00:02:54,000 --> 00:03:02,000
And finally, we want to position all students so that you can easily, if you like, compete for things like your office and summer jobs.

20
00:03:02,000 --> 00:03:08,000
Because you'll have an appropriate level of confidence and competence in your ability to do computational problem solving.

21
00:03:08,000 --> 00:03:10,000
Those are the strategic goals.

21
00:03:10,000 --> 00:03:19,000
Now, this course is primarily aimed at students who have little or no prior programming experience.

22
00:03:19,000 --> 00:03:26,000
As a consequence, we believe that no student here is under-qualified for this course: you're all MIT students, you're all qualified to be here.

23
00:03:26,000 --> 00:03:31,000
But we also hope that there aren't any students here who are over-qualified for this course.

24
00:03:31,000 --> 00:03:51,000
And what do I mean by that? If you've done a lot prior programming, this is probably not the best course for you, and if you're in that category, I would please encourage you to talk to John or I after class about what your goals are, what kind of experience you have, and how we might find you a course that better meets your goals.

25
00:03:51,000 --> 00:04:08,000
Second reason we don't want over-qualified students in the class, it sounds a little nasty, but the second reason is, an over-qualified student, somebody who's, I don't know, programmed for Google for the last five years, is going to have an easy time in this course, but we don't want such a student accidentally intimidating the rest of you.

26
00:04:08,000 --> 00:04:13,000
We don't want you to feel inadequate when you're simply inexperienced.

27
00:04:13,000 --> 00:04:18,000
And so, it really is a course aimed at students with little or no prior programming experience.

28
00:04:18,000 --> 00:04:24,000
And again, if you're not in that category, talk to John or I after class, and we'll help you figure out where you might want to go.

29
00:04:24,000 --> 00:04:24,000
OK.

29
00:04:24,000 --> 00:04:26,000
Those are the top-level goals of the course.

29
00:04:26,000 --> 00:04:31,000
Let's talk sort of at a more tactical level, about what do we want you to know in this course.

30
00:04:31,000 --> 00:04:41,000
What we want you to be able to do by the time you leave this course? So here are the skills that we would like you to acquire.

31
00:04:41,000 --> 00:04:50,000
Right, the first skill we want you to acquire, is we want you to be able to use the basic tools of computational thinking to write small scale programs. I'm going to keep

32
00:04:50,000 --> 00:04:57,000
coming back to that idea, but I'm going to call it computational thinking.

33
00:04:57,000 --> 00:05:00,000
And that's so you can write small pieces of code.

33
00:05:00,000 --> 00:05:05,000
And small is not derogatory here, by the way, it just says the size of things you're going to be able to do.

34
00:05:05,000 --> 00:05:15,000
Second skill we want you to have at the end of this course is the ability to use a vocabulary of computational tools in order to be able to understand programs written by others.

35
00:05:15,000 --> 00:05:19,000
So you're going to be able to write, you're going to be able to read.

36
00:05:19,000 --> 00:05:24,000
This latter skill, by the way, is incredibly valuable.

36
00:05:24,000 --> 00:05:34,000
Because you won't want to do everything from scratch yourself, you want to be able to look at what is being created by somebody else and understand what is inside of there, whether it works correctly and how you can build on it.

37
00:05:34,000 --> 00:05:37,000
This is one of the few places where plagiarism is an OK thing.

38
00:05:37,000 --> 00:05:42,000
It's not bad to, if you like, learn from the skills of others in order to create something you want to write.

39
00:05:42,000 --> 00:05:46,000
Although we'll come back to plagiarism as a bad thing later on.

40
00:05:46,000 --> 00:05:55,000
Third thing we want you to do, is to understand the fundamental both capabilities and limitations of computations, and the costs associated with them.

41
00:05:55,000 --> 00:05:59,000
And that latter statement sounds funny, you don't think of computations having limits, but they do.

42
00:05:59,000 --> 00:06:01,000
There're some things that cannot be computed.

42
00:06:01,000 --> 00:06:03,000
We want you to understand where those limits are.

42
00:06:03,000 --> 00:06:15,000
So you're going to be able to understand abilities and limits.

43
00:06:15,000 --> 00:06:24,000
And then, finally, the last tactical skill that you're going to get out of this course is you're going to have the ability to map scientific problems into a computational frame.

44
00:06:24,000 --> 00:06:37,000
So you're going to be able to take a description of a problem and map it into something computational.

45
00:06:37,000 --> 00:06:41,000
Now if you think about it, boy, it sounds like grammar school.

46
00:06:41,000 --> 00:07:01,000
We're going to teach you to read, we're going to teach you to write, we're going to teach you to understand what you can and cannot do, and most importantly, we're going to try and give you the start of an ability to take a description of a problem from some other domain, and figure out how to map it into that domain of computation so you can do the reading and writing that you want to do.

47
00:07:01,000 --> 00:07:11,000
OK, in a few minutes we're going to start talking then about what is computation, how are we going to start building those tools, but that's what you should take away, that's what you're going to gain out of this course by the time you're done.

48
00:07:11,000 --> 00:07:20,000
Now, let me take a sidebar for about five minutes to talk about course administration, the administrivia, things that we're going to do in the course, just so you know what the rules are.

49
00:07:20,000 --> 00:07:24,000
Right, so, class is two hours of lecture a week.

49
00:07:24,000 --> 00:07:27,000
You obviously know where and you know when, because you're here.

50
00:07:27,000 --> 00:07:29,000
Tuesdays and Thursdays at 11:00.

50
00:07:29,000 --> 00:07:34,000
One hour of recitation a week, on Fridays, and we'll come back in a second to how you're going to get set up for that.

51
00:07:34,000 --> 00:07:38,000
And nine hours a week of outside-the-class work.

51
00:07:38,000 --> 00:07:48,000
Those nine hours are going to be primarily working on problem sets, and all the problems sets are going to involve programming in Python, which is the language we're going to be using this term.

52
00:07:48,000 --> 00:07:51,000
Now, one of the things you're going to see is the first problem sets are pretty easy.

53
00:07:51,000 --> 00:07:54,000
Actually, that's probably wrong, John, right? They're very easy.

54
00:07:54,000 --> 00:07:55,000
And we're going to ramp up.

54
00:07:55,000 --> 00:08:04,000
By the time you get to the end of the term, you're going to be dealing with some fairly complex things, so one of the things you're going to see is, we're going to make heavy use of libraries, or code written by others.

55
00:08:04,000 --> 00:08:13,000
It'll allow you to tackle interesting problems I'll have you to write from scratch, but it does mean that this skill here is going to be really valuable.

56
00:08:13,000 --> 00:08:18,000
You need to be able to read that code and understand it, as well as write your own.

57
00:08:18,000 --> 00:08:19,000
OK.

57
00:08:19,000 --> 00:08:20,000
Two quizzes.

57
00:08:20,000 --> 00:08:23,000
During the term, the dates have already been scheduled.

57
00:08:23,000 --> 00:08:29,000
John, I forgot to look them up, I think it's October 2nd and November 4th, it'll be on the course website.

58
00:08:29,000 --> 00:08:34,000
My point is, go check the course website, which by the way is right there.

59
00:08:34,000 --> 00:08:40,000
If you have, if you know you have a conflict with one of those quiz dates now, please see John or I right away.

60
00:08:40,000 --> 00:08:42,000
We'll arrange something ahead of time.

60
00:08:42,000 --> 00:08:49,000
But if you-- The reason I'm saying that is, you know, you know that you're getting married that day for example, we will excuse you from the quiz to get married.

61
00:08:49,000 --> 00:08:54,000
We'll expect you come right back to do the quiz by the way, but the-- Boy, tough crowd.

62
00:08:54,000 --> 00:08:57,000
All right.

62
00:08:57,000 --> 00:08:59,000
If you have a conflict, please let us know.

62
00:08:59,000 --> 00:09:07,000
Second thing is, if you have an MIT documented special need for taking quizzes, please see John or I well in advance.

63
00:09:07,000 --> 00:09:08,000
At least two weeks before the quiz.

63
00:09:08,000 --> 00:09:13,000
Again, we'll arrange for this, but you need to give us enough warning so that we can deal with that.

64
00:09:13,000 --> 00:09:16,000
OK, the quizzes are open book.

64
00:09:16,000 --> 00:09:20,000
This course is not about memory.

64
00:09:20,000 --> 00:09:29,000
It's not how well you can memorize facts: in fact, I think both John and I are a little sensitive to memory tests, given our age, right John? This is not about how you memorize things, it's about how you think.

65
00:09:29,000 --> 00:09:30,000
So they're open note, open book.

65
00:09:30,000 --> 00:09:34,000
It's really going to test your ability to think.

65
00:09:34,000 --> 00:09:48,000
The grades for the course will be assigned roughly, and I use the word roughly because we reserve the right to move these numbers around a little bit, but basically in the following percentages: 55% of your grade comes from the problem sets, the other 45% come from the quizzes.

66
00:09:48,000 --> 00:09:50,000
And I should've said there's two quizzes and a final exam.

66
00:09:50,000 --> 00:09:52,000
I forgot, that final exam during final period.

66
00:09:52,000 --> 00:09:55,000
So the quiz percentages are 10%, 15%, and 20%.

66
00:09:55,000 --> 00:09:59,000
Which makes up the other 45%.

66
00:09:59,000 --> 00:10:00,000
OK.

66
00:10:00,000 --> 00:10:02,000
Other administrivia.

66
00:10:02,000 --> 00:10:05,000
Let me just look through my list here.

66
00:10:05,000 --> 00:10:07,000
First problem set, problem set zero, has already been posted.

66
00:10:07,000 --> 00:10:09,000
This is a really easy one.

66
00:10:09,000 --> 00:10:11,000
We intend it to be a really easy problem set.

66
00:10:11,000 --> 00:10:17,000
It's basically to get you to load up Python on your machine and make sure you understand how to interact with it.

67
00:10:17,000 --> 00:10:26,000
The first problem set will be posted shortly, it's also pretty boring-- somewhat like my lectures but not John's-- and that means, you know, we want you just to get going on things.

68
00:10:26,000 --> 00:10:28,000
Don't worry, we're going to make them more interesting as you go along.

69
00:10:28,000 --> 00:10:33,000
Nonetheless, I want to stress that none of these problems sets are intended to be lethal.

70
00:10:33,000 --> 00:10:36,000
We're not using them to weed you out, we're using them to help you learn.

71
00:10:36,000 --> 00:10:43,000
So if you run into a problem set that just, you don't get, all right? Seek help.

72
00:10:43,000 --> 00:10:46,000
Could be psychiatric help, could be a TA.

72
00:10:46,000 --> 00:10:47,000
I recommend the TA.

72
00:10:47,000 --> 00:10:50,000
My point being, please come and talk to somebody.

72
00:10:50,000 --> 00:10:56,000
The problems are set up so that, if you start down the right path, it should be pretty straight-forward to work it through.

73
00:10:56,000 --> 00:11:03,000
If you start down a plausible but incorrect path, you can sometimes find yourself stuck in the weeds somewhere, and we want to bring you back in.

74
00:11:03,000 --> 00:11:12,000
So part of the goal here is, this should not be a grueling, exhausting kind of task, it's really something that should be helping you learn the material.

75
00:11:12,000 --> 00:11:15,000
If you need help, ask John, myself, or the TAs.

75
00:11:15,000 --> 00:11:17,000
That's what we're here for.

75
00:11:17,000 --> 00:11:18,000
OK.

75
00:11:18,000 --> 00:11:23,000
We're going to run primarily a paperless subject, that's why the website is there.

76
00:11:23,000 --> 00:11:27,000
Please check it, that's where everything's going to be posted in terms of things you need to know.

77
00:11:27,000 --> 00:11:35,000
In particular, please go to it today, you will find a form there that you need to fill out to register for, or sign up for rather, a recitation.

78
00:11:35,000 --> 00:11:37,000
Recitations are on Friday.

78
00:11:37,000 --> 00:11:41,000
Right now, we have them scheduled at 9:00, 10:00, 11:00, 12:00, 1:00, and 2:00.

79
00:11:41,000 --> 00:11:49,000
We may drop one of the recitations, just depending on course size, all right? So we reserve the right, unfortunately, to have to move you around.

80
00:11:49,000 --> 00:11:54,000
My guess is that 9:00 is not going to be a tremendously popular time, but maybe you'll surprise me.

81
00:11:54,000 --> 00:11:56,000
Nonetheless, please go in and sign up.

81
00:11:56,000 --> 00:11:59,000
We will let you sign up for whichever recitation makes sense for you.

82
00:11:59,000 --> 00:12:08,000
Again, we reserve the right to move people around if we have to, just to balance load, but we want you to find something that fits your schedule rather than ours.

83
00:12:08,000 --> 00:12:09,000
OK.

83
00:12:09,000 --> 00:12:10,000
Other things.

83
00:12:10,000 --> 00:12:12,000
There is no required text.

83
00:12:12,000 --> 00:12:24,000
If you feel exposed without a text book, you really have to have a textbook, you'll find one recommended-- actually I'm going to reuse that word, John, at least suggest it, on the course website.

84
00:12:24,000 --> 00:12:28,000
I don't think either of us are thrilled with the text, it's the best we've probably found for Python, it's OK.

85
00:12:28,000 --> 00:12:29,000
If you need it, it's there.

85
00:12:29,000 --> 00:12:33,000
But we're going to basically not rely on any specific text.

85
00:12:33,000 --> 00:12:34,000
Right.

85
00:12:34,000 --> 00:12:38,000
Related to that: attendance here is obviously not mandatory.

86
00:12:38,000 --> 00:12:40,000
You ain't in high school anymore.

86
00:12:40,000 --> 00:12:46,000
I think both of us would love to see your smiling faces, or at least your faces, even if you're not smiling at us every day.

87
00:12:46,000 --> 00:12:57,000
Point I want to make about this, though, is that we are going to cover a lot of material that is not in the assigned readings, and we do have assigned readings associated with each one of these lectures.

88
00:12:57,000 --> 00:13:14,000
If you choose not to show up today-- or sorry, you did choose to show up today, if you choose not to show up in future days-- we'll understand, but please also understand that the TAs won't have a lot of patience with you if you're asking a question about something that was either covered in the readings, or covered in the lecture and is pretty straight forward.

89
00:13:14,000 --> 00:13:18,000
All right? We expect you to behave responsibly and we will as well.

90
00:13:18,000 --> 00:13:20,000
All right.

90
00:13:20,000 --> 00:13:26,000
I think the last thing I want to say is, we will not be handing out class notes.

91
00:13:26,000 --> 00:13:29,000
Now this sounds like a draconian measure; let me tell you why.

92
00:13:29,000 --> 00:13:36,000
Every study I know of, and I suspect every one John knows, about learning, stresses that students learn best when they take notes.

93
00:13:36,000 --> 00:13:40,000
Ironically, even if they never look at them.

93
00:13:40,000 --> 00:13:40,000
OK.

93
00:13:40,000 --> 00:13:48,000
The process of writing is exercising both halves of your brain, and it's actually helping you learn, and so taking notes is really valuable thing.

94
00:13:48,000 --> 00:13:50,000
Therefore we're not going to distribute notes.

94
00:13:50,000 --> 00:13:55,000
What we will distribute for most lectures is a handout that's mostly code examples that we're going to do.

95
00:13:55,000 --> 00:13:58,000
I don't happen to have one today because we're not going to do a lot of code.

96
00:13:58,000 --> 00:13:59,000
We will in future.

96
00:13:59,000 --> 00:14:10,000
Those notes are going to make no sense, I'm guessing, outside of the lecture, all right? So it's not just, you can swing by 11:04 and grab a copy and go off and catch some more sleep.

97
00:14:10,000 --> 00:14:17,000
What we recommend is you use those notes to take your own annotations to help you understand what's going on, but we're not going to provide class notes.

98
00:14:17,000 --> 00:14:23,000
We want you to take your own notes to help you, if you like, spur your own learning process.

99
00:14:23,000 --> 00:14:24,000
All right.

99
00:14:24,000 --> 00:14:32,000
And then finally, I want to stress that John, myself, all of the staff, our job is to help you learn.

100
00:14:32,000 --> 00:14:32,000
That's what we're here for.

100
00:14:32,000 --> 00:14:35,000
It's what we get excited about.

100
00:14:35,000 --> 00:14:40,000
If you're stuck, if you're struggling, if you're not certain about something, please ask.

101
00:14:40,000 --> 00:14:48,000
We're not mind readers, we can't tell when you're struggling, other than sort of seeing the expression on your face, we need your help in identifying that.

102
00:14:48,000 --> 00:14:53,000
But all of the TAs, many of whom are sitting down in the front row over here, are here to help, so come and ask.

103
00:14:53,000 --> 00:14:56,000
At the same time, remember that they're students too.

103
00:14:56,000 --> 00:15:05,000
And if you come and ask a question that you could have easily answered by doing the reading, coming to lecture, or using Google, they're going to have less patience.

104
00:15:05,000 --> 00:15:14,000
But helping you understand things that really are a conceptual difficulty is what they're here for and what we're here for, so please come and talk to us.

105
00:15:14,000 --> 00:15:15,000
OK.

105
00:15:15,000 --> 00:15:17,000
That takes care of the administrivia preamble.

105
00:15:17,000 --> 00:15:34,000
John, things we add? PROFESSOR GUTTAG: Two more quick things.

106
00:15:34,000 --> 00:15:35,000
This semester, your class is being videotaped for OpenCourseware.

107
00:15:35,000 --> 00:15:38,000
If any of you don't want your image recorded and posted on the web, you're supposed to sit in the back three rows.

108
00:15:38,000 --> 00:15:39,000
PROFESSOR GRIMSON: Ah, thank you.

108
00:15:39,000 --> 00:15:39,000
I forgot.

108
00:15:39,000 --> 00:15:40,000
PROFESSOR GUTTAG: --Because the camera may pan.

108
00:15:40,000 --> 00:15:40,000
I think you're all very good-looking and give MIT a good image, so please, feel free to be filmed.

109
00:15:40,000 --> 00:15:48,000
PROFESSOR GRIMSON: I'll turn around, so if you want to, you know, move to the back, I won't see who moves.

110
00:15:48,000 --> 00:15:48,000
Right.

110
00:15:48,000 --> 00:15:48,000
Great.

110
00:15:48,000 --> 00:15:49,000
Thank you, John.

110
00:15:49,000 --> 00:16:00,000
PROFESSOR GUTTAG: So that, the other thing I want to mention is, recitations are also very important.

111
00:16:00,000 --> 00:16:03,000
We will be covering material in recitations that're not in the lectures, not in the reading, and we do expect you to attend recitations.

112
00:16:03,000 --> 00:16:04,000
PROFESSOR GRIMSON: Great.

112
00:16:04,000 --> 00:16:06,000
Thanks, John.

112
00:16:06,000 --> 00:16:12,000
Any questions about the administrivia? I know it's boring, but we need to do it so you know what the ground rules are.

113
00:16:12,000 --> 00:16:13,000
Good.

113
00:16:13,000 --> 00:16:14,000
OK.

113
00:16:14,000 --> 00:16:16,000
Let's talk about computation.

113
00:16:16,000 --> 00:16:23,000
As I said, our strategic goal, our tactical goals, are to help you think like a computer scientist. Another way of

114
00:16:23,000 --> 00:16:28,000
saying it is, we want to give you the skill so that you can make the computer do what you want it to do.

115
00:16:28,000 --> 00:16:41,000
And we hope that at the end of the class, every time you're confronted with some technical problem, one of your first instincts is going to be, "How do I write the piece of code that's going to help me solve that?" So we want to help you think like a computer scientist. All right.

116
00:16:41,000 --> 00:16:45,000
And that, is an interesting statement.

116
00:16:45,000 --> 00:16:59,000
What does it mean, to think like a computer scientist? Well, let's see.

117
00:16:59,000 --> 00:17:07,000
The primary knowledge you're going to take away from this course is this notion of computational problem solving, this ability to think in computational modes of thought.

118
00:17:07,000 --> 00:17:13,000
And unlike in a lot of introductory courses, as a consequence, having the ability to memorize is not going to help you.

119
00:17:13,000 --> 00:17:18,000
It's really learning those notions of the tools that you want to use.

120
00:17:18,000 --> 00:17:24,000
What in the world does it mean to say computational mode of thought? It sounds like a hifalutin phrase you use when you're trying to persuade a VC to fund you.

121
00:17:24,000 --> 00:17:25,000
Right.

121
00:17:25,000 --> 00:17:47,000
So to answer this, we really have to ask a different question, a related question; so, what's computation? It's like a strange statement, right? What is computation? And part of the reason for putting it up is that I want to, as much as possible, answer that question by separating out the mechanism, which is the computer, from computational thinking.

122
00:17:47,000 --> 00:17:47,000
Right.

122
00:17:47,000 --> 00:17:49,000
The artifact should not be what's driving this.

122
00:17:49,000 --> 00:17:56,000
It should be the notion of, "What does it mean to do computation?" Now, to answer that, I'm going to back up one more level.

123
00:17:56,000 --> 00:18:02,000
And I'm going to pose what sounds like a philosophy question, which is, "What is knowledge?" And you'll see in about two minutes why I'm going to do this.

124
00:18:02,000 --> 00:18:07,000
But I'm going to suggest that I can divide knowledge into at least two categories.

125
00:18:07,000 --> 00:18:19,000
OK, and what is knowledge? And the two categories I'm going to divide them into are declarative and imperative knowledge.

126
00:18:19,000 --> 00:18:20,000
Right.

126
00:18:20,000 --> 00:18:25,000
What in the world is declarative knowledge? Think of it as statements of fact.

127
00:18:25,000 --> 00:18:27,000
It's assertions of truth.

127
00:18:27,000 --> 00:18:32,000
Boy, in this political season, that's a really dangerous phrase to use, right? But it's a statement of fact.

128
00:18:32,000 --> 00:18:34,000
I'll stay away from the political comments.

128
00:18:34,000 --> 00:18:35,000
Let me give you an example of this.

128
00:18:35,000 --> 00:18:36,000
Right.

128
00:18:36,000 --> 00:18:37,000
Here's a declarative statement.

128
00:18:37,000 --> 00:18:48,000
The square root of x is that y such that y squared equals x, y's positive.

129
00:18:48,000 --> 00:18:50,000
You all know that.

129
00:18:50,000 --> 00:18:54,000
But what I want you to see here, is that's a statement of fact.

130
00:18:54,000 --> 00:18:55,000
It's a definition.

130
00:18:55,000 --> 00:18:55,000
It's an axiom.

130
00:18:55,000 --> 00:19:00,000
It doesn't help you find square roots.

130
00:19:00,000 --> 00:19:06,000
If I say x is 2, I want to know, what's the square root of 2, well if you're enough of a geek, you'll say 1.41529 or

131
00:19:06,000 --> 00:19:12,000
whatever the heck it is, but in general, this doesn't help you find the square root.

132
00:19:12,000 --> 00:19:15,000
The closest it does is it would let you test. You know,

132
00:19:15,000 --> 00:19:26,000
if you're wandering through Harvard Square and you see an out-of-work Harvard grad, they're handing out examples of square roots, they'll give you an example and you can test it to see, is the square root of 2, 1.41529 or whatever.

133
00:19:26,000 --> 00:19:36,000
I don't even get laughs at Harvard jokes, John, I'm going to stop in a second here, all right? All right, so what am I trying to say here? It doesn't -- yeah, exactly.

134
00:19:36,000 --> 00:19:39,000
We're staying away from that, really quickly, especially with the cameras rolling.

135
00:19:39,000 --> 00:19:40,000
All right.

135
00:19:40,000 --> 00:19:46,000
What am I trying to say? It tells you how you might test something but it doesn't tell you how to.

136
00:19:46,000 --> 00:19:48,000
And that's what imperative knowledge is.

136
00:19:48,000 --> 00:19:52,000
Imperative knowledge is a description of how to deduce something.

137
00:19:52,000 --> 00:19:56,000
So let me give you an example of a piece of imperative knowledge.

138
00:19:56,000 --> 00:20:07,000
All right, this is actually a very old piece of imperative knowledge for computing square roots, it's attributed to Heron of Alexandria, although I believe that the Babylonians are suspected of knowing it beforehand.

139
00:20:07,000 --> 00:20:09,000
But here is a piece of imperative knowledge.

139
00:20:09,000 --> 00:20:17,000
All right? I'm going to start with a guess, I'm going to call it g.

140
00:20:17,000 --> 00:20:26,000
And then I'm going to say, if g squared is close to x, stop.

140
00:20:26,000 --> 00:20:28,000
And return g.

140
00:20:28,000 --> 00:20:30,000
It's a good enough answer.

140
00:20:30,000 --> 00:20:42,000
Otherwise, I'm going to get a new guess by taking g, x over g, adding them, and dividing by two.

141
00:20:42,000 --> 00:20:44,000
Then you take the average of g and x over g.

141
00:20:44,000 --> 00:20:47,000
Don't worry about how came about, Heron found this out.

141
00:20:47,000 --> 00:20:56,000
But that gives me a new guess, and I'm going to repeat.

141
00:20:56,000 --> 00:20:58,000
That's a recipe.

141
00:20:58,000 --> 00:21:01,000
That's a description of a set of steps.

141
00:21:01,000 --> 00:21:10,000
Notice what it has, it has a bunch of nice things that we want to use, right? It's a sequence of specific instructions that I do in order.

142
00:21:10,000 --> 00:21:18,000
Along the way I have some tests, and depending on the value of that test, I may change where I am in that sequence of instructions.

143
00:21:18,000 --> 00:21:22,000
And it has an end test, something that tells me when I'm done and what the answer is.

144
00:21:22,000 --> 00:21:24,000
This tells you how to find square roots.

144
00:21:24,000 --> 00:21:25,000
it's how-to knowledge.

144
00:21:25,000 --> 00:21:27,000
It's imperative knowledge.

144
00:21:27,000 --> 00:21:27,000
All right.

144
00:21:27,000 --> 00:21:31,000
That's what computation basically is about.

144
00:21:31,000 --> 00:21:35,000
We want to have ways of capturing this process.

144
00:21:35,000 --> 00:21:57,000
OK, and that leads now to an interesting question, which would be, "How do I build a mechanical process to capture that set of computations?" So I'm going to suggest that there's an easy way to do it-- I realized I did the boards in the wrong order here-- one of the ways I could do it is, you could imagine building a little circuit to do this.

145
00:21:57,000 --> 00:22:09,000
If I had a couple of elements of stored values in it, I had some wires to move things around, I had a little thing to do addition, little thing to do division, and a something to do the testing, I could build a little circuit that would actually do this computation.

146
00:22:09,000 --> 00:22:11,000
OK.

146
00:22:11,000 --> 00:22:35,000
That, strange as it sounds, is actually an example of the earliest computers, because the earliest computers were what we call fixed-program computers, meaning that they had a piece of circuitry designed to do a specific computation.

147
00:22:35,000 --> 00:22:40,000
And that's what they would do: they would do that specific computation.

148
00:22:40,000 --> 00:22:47,000
You've seen these a lot, right? A good example of this: calculator.

149
00:22:47,000 --> 00:22:51,000
It's basically an example of a fixed-program computer.

149
00:22:51,000 --> 00:22:53,000
It does arithmetic.

149
00:22:53,000 --> 00:22:55,000
If you want play video games on it, good luck.

149
00:22:55,000 --> 00:22:58,000
If you want to do word processing on it, good luck.

149
00:22:58,000 --> 00:23:00,000
It's designed to do a specific thing.

149
00:23:00,000 --> 00:23:03,000
It's a fixed-program computer.

149
00:23:03,000 --> 00:23:14,000
In fact, a lot of the other really interesting early ones similarly have this flavor, to give an example: I never know how to pronounce this, Atanasoff, 1941.

150
00:23:14,000 --> 00:23:22,000
One of the earliest computational things was a thing designed by a guy named Atanasoff, and it basically solved linear equations.

151
00:23:22,000 --> 00:23:29,000
Handy thing to do if you're doing 1801, all right, or 1806, or whatever you want to do those things in.

152
00:23:29,000 --> 00:23:31,000
All it could do, though, was solve those equations.

152
00:23:31,000 --> 00:23:43,000
One of my favorite examples of an early computer was done by Alan Turing, one of the great computer scientists of all time, called the bombe, which was designed to break codes.

153
00:23:43,000 --> 00:23:46,000
It was actually used during WWII to break German Enigma codes.

154
00:23:46,000 --> 00:23:49,000
And what it was designed to do, was to solve that specific problem.

155
00:23:49,000 --> 00:23:55,000
The point I'm trying to make is, fixed-program computers is where we started, but it doesn't really get us to where we'd like to be.

156
00:23:55,000 --> 00:23:58,000
We want to capture this idea of problem solving.

156
00:23:58,000 --> 00:24:01,000
So let's see how we'd get there.

156
00:24:01,000 --> 00:24:13,000
So even within this framework of, given a description of a computation as a set of steps, in the idea that I could build a circuit to do it, let me suggest for you what would be a wonderful circuit to build.

157
00:24:13,000 --> 00:24:20,000
Suppose you could build a circuit with the following property: the input to this circuit would be any other circuit diagram.

158
00:24:20,000 --> 00:24:30,000
Give it a circuit diagram for some computation, you give it to the circuit, and that circuit would wonderfully reconfigure itself to act like the circuits diagram.

159
00:24:30,000 --> 00:24:33,000
Which would mean, it could act like a calculator.

159
00:24:33,000 --> 00:24:35,000
Or, it could act like Turing's bombe.

159
00:24:35,000 --> 00:24:38,000
Or, it could act like a square root machine.

159
00:24:38,000 --> 00:24:45,000
So what would that circuit look like? You can imagine these tiny little robots wandering around, right? Pulling wires and pulling out components and stacking them together.

160
00:24:45,000 --> 00:24:55,000
How would you build a circuit that could take a circuit diagram in and make a machine act like that circuit? Sounds like a neat challenge.

161
00:24:55,000 --> 00:24:59,000
Let me change the game slightly.

161
00:24:59,000 --> 00:25:15,000
Suppose instead, I want a machine that can take a recipe, the description of a sequence of steps, take that as its input, and then that machine will now act like what is described in that recipe.

162
00:25:15,000 --> 00:25:21,000
Reconfigure itself, emulate it, however you want to use the words, it's going to change how it does the computation.

163
00:25:21,000 --> 00:25:23,000
That would be cool.

163
00:25:23,000 --> 00:25:24,000
And that exists.

163
00:25:24,000 --> 00:25:26,000
It's called an interpreter.

163
00:25:26,000 --> 00:25:29,000
It is the basic heart of every computer.

163
00:25:29,000 --> 00:25:33,000
What it is doing, is saying, change the game.

163
00:25:33,000 --> 00:25:40,000
This is now an example of a stored-program computer.

163
00:25:40,000 --> 00:25:55,000
What that means, in a stored-program computer, is that I can provide to the computer a sequence of instructions describing the process I want it to execute.

164
00:25:55,000 --> 00:26:09,000
And inside of the machine, and things we'll talk about, there is a process that will allow that sequence to be executed as described in that recipe, so it can behave like any thing that I can describe in one of those recipes.

165
00:26:09,000 --> 00:26:10,000
All right.

165
00:26:10,000 --> 00:26:19,000
That actually seems like a really nice thing to have, and so let me show you what that would basically look like.

166
00:26:19,000 --> 00:26:55,000
Inside of a stored-program computer, we would have the following: we have a memory, it's connected to two things; control unit, in what's called an ALU, an arithmetic logic unit, and this can take in input, and spit out output, and inside this stored-program computer, excuse me, you have the following: you have a sequence of instructions.

167
00:26:55,000 --> 00:27:03,000
And these all get stored in there.

167
00:27:03,000 --> 00:27:05,000
Notice the difference.

167
00:27:05,000 --> 00:27:10,000
The recipe, the sequence of instructions, is actually getting read in, and it's treated just like data.

168
00:27:10,000 --> 00:27:19,000
It's inside the memory of the machine, which means we have access to it, we can change it, we can use it to build new pieces of code, as well as we can interpret it.

169
00:27:19,000 --> 00:27:31,000
One other piece that goes into this computer-- I never remember where to put the PC, John, control? ALU? Separate? I'll put it separate-- you have a thing called a program counter.

170
00:27:31,000 --> 00:27:34,000
And here's the basis of the computation.

170
00:27:34,000 --> 00:27:43,000
That program counter points to some location in memory, typically to the first instruction in the sequence.

171
00:27:43,000 --> 00:27:54,000
And those instructions, by the way, are very simple: they're things like, take the value out of two places in memory, and run them through the multiplier in here, a little piece of circuitry, and stick them back into someplace in memory.

172
00:27:54,000 --> 00:28:00,000
Or take this value out of memory, run it through some other simple operation, stick it back in memory.

173
00:28:00,000 --> 00:28:05,000
Having executed this instruction, that counter goes up by one and we move to the next one.

174
00:28:05,000 --> 00:28:08,000
We execute that instruction, we move to the next one.

174
00:28:08,000 --> 00:28:13,000
Oh yeah, it looks a whole lot like that.

174
00:28:13,000 --> 00:28:30,000
Some of those instructions will involve tests: they'll say, is something true? And if the test is true, it will change the value of this program counter to point to some other place in the memory, some other point in that sequence of instructions, and you'll keep processing.

175
00:28:30,000 --> 00:28:34,000
Eventually you'll hopefully stop, and a value gets spit out, and you're done.

176
00:28:34,000 --> 00:28:35,000
That's the heart of a computer.

176
00:28:35,000 --> 00:28:37,000
Now that's a slight misstatement.

176
00:28:37,000 --> 00:28:47,000
The process to control it is intriguing and interesting, but the heart of the computer is simply this notion that we build our descriptions, our recipes, on a sequence of primitive instructions.

177
00:28:47,000 --> 00:28:50,000
And then we have a flow of control.

177
00:28:50,000 --> 00:28:51,000
And that flow of control is what I just described.

177
00:28:51,000 --> 00:28:57,000
It's moving through a sequence of instructions, occasionally changing where we are as we move around.

178
00:28:57,000 --> 00:28:58,000
OK.

178
00:28:58,000 --> 00:29:06,000
The thing I want you to take away from this, then, is to think of this as, this is, if you like, a recipe.

179
00:29:06,000 --> 00:29:19,000
And that's really what a program is.

179
00:29:19,000 --> 00:29:21,000
It's a sequence of instructions.

179
00:29:21,000 --> 00:29:24,000
Now, one of things I left hanging is, I said, OK, you build it out of primitives.

180
00:29:24,000 --> 00:29:37,000
So one of the questions is, well, what are the right primitives to use? And one of the things that was useful here is, that we actually know that the set of primitives that you want to use is very straight-forward.

181
00:29:37,000 --> 00:29:42,000
OK, but before I do that, let me drive home this idea of why this is a recipe.

182
00:29:42,000 --> 00:29:47,000
Assuming I have a set of primitive instructions that I can describe everything on, I want to know what can I build.

183
00:29:47,000 --> 00:29:49,000
Well, I'm going to do the same analogy to a real recipe.

183
00:29:49,000 --> 00:29:51,000
So, real recipe.

183
00:29:51,000 --> 00:29:51,000
I don't know.

183
00:29:51,000 --> 00:29:54,000
Separate six eggs.

183
00:29:54,000 --> 00:29:55,000
Do something.

183
00:29:55,000 --> 00:29:59,000
Beat until the-- sorry, beat the whites until they're stiff.

184
00:29:59,000 --> 00:30:02,000
Do something until an end test is true.

184
00:30:02,000 --> 00:30:05,000
Take the yolks and mix them in with the sugar and water-- No.

185
00:30:05,000 --> 00:30:11,000
Sugar and flour I guess is probably what I want, sugar and water is not going to do anything interesting for me here-- mix them into something else.

186
00:30:11,000 --> 00:30:13,000
Do a sequence of things.

186
00:30:13,000 --> 00:30:26,000
A traditional recipe actually is based on a small set of primitives, and a good chef with, or good cook, I should say, with that set of primitives, can create an unbounded number of great dishes.

187
00:30:26,000 --> 00:30:28,000
Same thing holds true in programming.

187
00:30:28,000 --> 00:30:29,000
Right.

187
00:30:29,000 --> 00:30:43,000
Given a fixed set of primitives, all right, a good programmer can program anything.

188
00:30:43,000 --> 00:30:49,000
And by that, I mean anything that can be described in one of these process, you can capture in that set of primitives.

189
00:30:49,000 --> 00:30:55,000
All right, the question is, as I started to say, is, "What are the right primitives?" So there's a little bit of, a little piece of history here, if you like.

190
00:30:55,000 --> 00:31:12,000
In 1936, that same guy, Alan Turing, showed that with six simple primitives, anything that could be described in a mechanical process, it's actually algorithmically, could be programmed just using those six primitives.

191
00:31:12,000 --> 00:31:14,000
Think about that for a second.

191
00:31:14,000 --> 00:31:16,000
That's an incredible statement.

191
00:31:16,000 --> 00:31:20,000
It says, with six primitives, I can rule the world.

191
00:31:20,000 --> 00:31:23,000
With six primitives, I can program anything.

191
00:31:23,000 --> 00:31:33,000
A couple of really interesting consequences of that, by the way, one of them is, it says, anything you can do in one programming language, you can do in another programming language.

192
00:31:33,000 --> 00:31:43,000
And there is no programming language that is better-- well actually, that's not quite true, there are some better at doing certain kinds of things-- but there's nothing that you can do in C that you can't do in Fortran.

193
00:31:43,000 --> 00:31:45,000
It's called Turing compatibility.

193
00:31:45,000 --> 00:31:49,000
Anything you can do with one, you can do with another, it's based on that fundamental result.

194
00:31:49,000 --> 00:31:50,000
OK.

194
00:31:50,000 --> 00:32:01,000
Now, fortunately we're not going to start with Turing's six primitives, this would be really painful programming, because they're down at the level of, "take this value and write it onto this tape." First of all, we don't have

195
00:32:01,000 --> 00:32:05,000
tapes anymore in computers, and even if we did, you don't want to be programming at that level.

196
00:32:05,000 --> 00:32:09,000
What we're going to see with programming language is that we're going to use higher-level abstracts.

197
00:32:09,000 --> 00:32:13,000
A broader set of primitives, but nonetheless the same fundamental thing holds.

198
00:32:13,000 --> 00:32:16,000
With those six primitives, you can do it.

198
00:32:16,000 --> 00:32:18,000
OK.

198
00:32:18,000 --> 00:32:33,000
So where are we here? What we're saying is, in order to do computation, we want to describe recipes, we want to describe this sequence of steps built on some primitives, and we want to describe the flow of control that goes through those sequence of steps as we carry on.

199
00:32:33,000 --> 00:32:39,000
So the last thing we need before we can start talking about real programming is, we need to describe those recipes.

200
00:32:39,000 --> 00:32:54,000
All right, And to describe the recipes, we're going to want a language.

201
00:32:54,000 --> 00:33:01,000
We need to know not only what are the primitives, but how do we make things meaningful in that language.

202
00:33:01,000 --> 00:33:03,000
Language.

202
00:33:03,000 --> 00:33:05,000
There we go.

202
00:33:05,000 --> 00:33:07,000
All right.

202
00:33:07,000 --> 00:33:13,000
Now, it turns out there are-- I don't know, John, hundreds? Thousands? Of programming languages? At least hundreds-- of programming languages around.

203
00:33:13,000 --> 00:33:16,000
PROFESSOR JOHN GUTTAG: [UNINTELLIGIBLE] PROFESSOR ERIC GRIMSON: True.

204
00:33:16,000 --> 00:33:18,000
Thank you.

204
00:33:18,000 --> 00:33:21,000
You know, they all have, you know, their pluses and minuses.

205
00:33:21,000 --> 00:33:33,000
I have to admit, in my career here, I think I've taught in at least three languages, I suspect you've taught more, five or six, John? Both of us have probably programmed in more than those number of languages, at least programmed that many, since we taught in those languages.

206
00:33:33,000 --> 00:33:36,000
One of the things you want to realize is, there is no best language.

207
00:33:36,000 --> 00:33:38,000
At least I would argue that, I think John would agree.

207
00:33:38,000 --> 00:33:43,000
We might both agree we have our own nominees for worst language, there are some of those.

208
00:33:43,000 --> 00:33:44,000
There is no best language.

208
00:33:44,000 --> 00:33:46,000
All right? They all are describing different things.

209
00:33:46,000 --> 00:33:51,000
Having said that, some of them are better suited for some things than others.

210
00:33:51,000 --> 00:34:01,000
Anybody here heard of MATLAB Maybe programmed in MATLAB? It's great for doing things with vectors and matrices and things that are easily captured in that framework.

211
00:34:01,000 --> 00:34:03,000
But there's some things that are a real pain to do in MATLAB.

212
00:34:03,000 --> 00:34:05,000
So MATLAB's great for that kind of thing.

212
00:34:05,000 --> 00:34:10,000
C is a great language for programming things that control data networks, for example.

213
00:34:10,000 --> 00:34:16,000
I happen to be, and John teases me about this regularly, I'm an old-time Lisp programmer, and that's how I was trained.

214
00:34:16,000 --> 00:34:23,000
And I happen to like Lisp and Scheme, it's a great language when you're trying to deal with problems where you have arbitrarily structured data sets.

215
00:34:23,000 --> 00:34:25,000
It's particularly good at that.

215
00:34:25,000 --> 00:34:30,000
So the point I want to make here is that there's no particularly best language.

216
00:34:30,000 --> 00:34:33,000
What we're going to do is simply use a language that helps us understand.

217
00:34:33,000 --> 00:34:38,000
So in this course, the language we're going to use is Python.

218
00:34:38,000 --> 00:34:48,000
Which is a pretty new language, it's growing in popularity, it has a lot of the elements of some other languages because it's more recent, it inherits things from it's pregenitors, if you like.

219
00:34:48,000 --> 00:34:54,000
But one of the things I want to stress is, this course is not about Python.

220
00:34:54,000 --> 00:34:55,000
Strange statement.

220
00:34:55,000 --> 00:35:00,000
You do need to know how to use it, but it's not about the details of, where do the semi-colons go in Python.

221
00:35:00,000 --> 00:35:04,000
All right? It's about using it to think.

222
00:35:04,000 --> 00:35:13,000
And what you should take away from this course is having learned how to design recipes, how to structure recipes, how to do things in modes in Python.

223
00:35:13,000 --> 00:35:16,000
Those same tools easily transfer to any other language.

224
00:35:16,000 --> 00:35:22,000
You can pick up another language in a week, couple of weeks at most, once you know how to do Python.

225
00:35:22,000 --> 00:35:23,000
OK.

225
00:35:23,000 --> 00:35:31,000
In order to talk about Python and languages, I want to do one last thing to set the stage for what we're going to do here, and that's to talk about the different dimensions of a language.

226
00:35:31,000 --> 00:35:33,000
And there're three I want to deal with.

226
00:35:33,000 --> 00:35:41,000
The first one is, whether this is a high-level or low-level language.

227
00:35:41,000 --> 00:35:54,000
That basically says, how close are you the guts of the machine? A low-level language, we used to call this assembly programming, you're down at the level of, your primitives are literally moving pieces of data from one location of memory to another, through a very simple operation.

228
00:35:54,000 --> 00:35:59,000
A high-level language, the designer has created a much richer set of primitive things.

229
00:35:59,000 --> 00:36:06,000
In a high-level language, square root might simply be a primitive that you can use, rather than you having to go over and code it.

230
00:36:06,000 --> 00:36:08,000
And there're trade-offs between both.

230
00:36:08,000 --> 00:36:15,000
Second dimension is, whether this is a general versus a targeted language.

231
00:36:15,000 --> 00:36:29,000
And by that I mean, do the set of primitives support a broad range of applications, or is it really aimed at a very specific set of applications? I'd argue that MATLAB is basically a targeted language, it's targeted at matrices and vectors and things like that.

232
00:36:29,000 --> 00:36:41,000
And the third one I want to point out is, whether this is an interpreted versus a compiled language.

233
00:36:41,000 --> 00:36:57,000
What that basically says is the following: in an interpreted language, you take what's called the source code, the thing you write, it may go through a simple checker but it basically goes to the interpreter, that thing inside the machine that's going to control the flow of going through each one of the instructions, and give you an output.

234
00:36:57,000 --> 00:37:02,000
So the interpreter is simply operating directly on your code at run time.

235
00:37:02,000 --> 00:37:11,000
In a compiled language, you have an intermediate step, in which you take the source code, it runs through what's called a checker or a compiler or both, and it creates what's called object code.

236
00:37:11,000 --> 00:37:24,000
And that does two things: one, it helps catch bugs in your code, and secondly it often converts it into a more efficient sequence of instructions before you actually go off and run it.

237
00:37:24,000 --> 00:37:25,000
All right? And there's trade-offs between both.

238
00:37:25,000 --> 00:37:32,000
I mean, an interpreted language is often easier to debug, because you can still see your raw code there, but it's not always as fast. A compiled language is usually

239
00:37:32,000 --> 00:37:34,000
much faster in terms of its execution.

239
00:37:34,000 --> 00:37:37,000
And it's one of the things you may want to trade off.

239
00:37:37,000 --> 00:37:38,000
Right.

239
00:37:38,000 --> 00:37:43,000
In the case of Python, it's a high-level language.

239
00:37:43,000 --> 00:37:47,000
I would argue, I think John would agree with me, it's basically a general-purpose language.

240
00:37:47,000 --> 00:37:53,000
It happens to be better suited for manipulating strings than numbers, for example, but it's really a general-purpose language.

241
00:37:53,000 --> 00:37:58,000
And it's primarily-- I shouldn't say primarily, it is an interpreted language.

242
00:37:58,000 --> 00:38:11,000
OK? As a consequence, it's not as good as helping debug, but it does let you-- sorry, that's the wrong way of saying-- it's not as good at catching some things before you run them, it is easier at some times in debugging as you go along on the fly.

243
00:38:11,000 --> 00:38:11,000
OK.

243
00:38:11,000 --> 00:38:22,000
So what does Python look like? In order to talk about Python-- actually, I'm going to do it this way-- we need to talk about how to write things in Python.

244
00:38:22,000 --> 00:38:26,000
Again, you have to let me back up slightly and set the stage.

244
00:38:26,000 --> 00:38:28,000
Our goal is to build recipes.

244
00:38:28,000 --> 00:38:30,000
You're all going to be great chefs by the time you're done here.

245
00:38:30,000 --> 00:38:40,000
All right? Our goal is to take problems and break them down into these computational steps, these sequence of instructions that'll allow us to capture that process.

246
00:38:40,000 --> 00:38:49,000
To do that, we need to describe: not only, what are the primitives, but how do we capture things legally in that language, and interact with the computer? And so for that, we need a language.

247
00:38:49,000 --> 00:38:58,000
We're about to start talking about the elements of the language, but to do that, we also need to separate out one last piece of distinction.

248
00:38:58,000 --> 00:39:02,000
Just like with a natural language, we're going to separate out syntax versus semantics.

249
00:39:02,000 --> 00:39:25,000
So what's syntax? Syntax basically says, what are the legal expressions in this language? Boy, my handwriting is atrocious, isn't it? There's a English sequence of words.

250
00:39:25,000 --> 00:39:28,000
It's not since syntactically correct, right? It's not a sentence.

251
00:39:28,000 --> 00:39:31,000
There's no verb in there anywhere, it's just a sequence of nouns.

252
00:39:31,000 --> 00:39:32,000
Same thing in our languages.

252
00:39:32,000 --> 00:39:38,000
We have to describe how do you put together legally formed expressions.

253
00:39:38,000 --> 00:39:42,000
OK? And as we add constructs to the language, we're going to talk about.

254
00:39:42,000 --> 00:39:48,000
Second thing we want to talk about very briefly as we go along is the semantics of the language.

255
00:39:48,000 --> 00:39:53,000
And here we're going to break out two pieces; static semantics and full semantics.

256
00:39:53,000 --> 00:40:05,000
Static semantics basically says which programs are meaningful.

257
00:40:05,000 --> 00:40:09,000
Which expressions make sense.

257
00:40:09,000 --> 00:40:17,000
Here's an English sentence.

257
00:40:17,000 --> 00:40:20,000
It's syntactically correct.

257
00:40:20,000 --> 00:40:23,000
Right? Noun phrase, verb, noun phrase.

258
00:40:23,000 --> 00:40:29,000
I'm not certain it's meaningful, unless you are in the habit of giving your furniture personal names.

259
00:40:29,000 --> 00:40:41,000
What's the point? Again, you can have things that are syntactically legal but not semantically meaningful, and static semantics is going to be a way of helping us decide what expressions, what pieces of code, actually have real meaning to it.

260
00:40:41,000 --> 00:40:53,000
All right? The last piece of it is, in addition to having static semantics, we have sort of full semantics.

261
00:40:53,000 --> 00:41:09,000
Which is, what does the program mean? Or, said a different way, what's going to happen when I run it? That's the meaning of the expression.

262
00:41:09,000 --> 00:41:10,000
That's what you want.

262
00:41:10,000 --> 00:41:16,000
All right? You want to know, what's the meaning of this piece of code? When I run it, what's going to happen? That's what I want to build.

263
00:41:16,000 --> 00:41:33,000
The reason for pulling this out is, what you're going to see is, that in most languages, and certainly in Python-- we got lots of help here-- all right, Python comes built-in with something that will check your static, sorry, your syntax for you.

264
00:41:33,000 --> 00:41:42,000
And in fact, as a sidebar, if you turn in a problem set that is not syntactically correct, there's a simple button that you push that will check your syntax.

265
00:41:42,000 --> 00:41:46,000
If you've turned in a program that's not syntactically correct, the TAs give you a zero.

266
00:41:46,000 --> 00:41:49,000
Because it said you didn't even take the time to make sure the syntax is correct.

267
00:41:49,000 --> 00:41:50,000
The system will help you find it.

267
00:41:50,000 --> 00:41:59,000
In Python, it'll find it, I think one bug at a time, right John? It finds one syntax error at a time, so you have to be a little patient to do it, but you can check that the syntax is right.

268
00:41:59,000 --> 00:42:21,000
You're going to see that we get some help here on the static semantics, and I'm going to do an example in a second, meaning that the system, some languages are better than others on it, but it will try and help you catch some things that are not semantically correct statically.

269
00:42:21,000 --> 00:42:23,000
In the case of Python, it does that I think all at run time.

269
00:42:23,000 --> 00:42:27,000
I'm looking to you again, John, I think there's no pre-time checks.

270
00:42:27,000 --> 00:42:31,000
Its-- sorry? PROFESSOR JOHN GUTTAG: [UNINTELLIGIBLE] PROFESSOR ERIC GRIMSON: There is some.

271
00:42:31,000 --> 00:42:32,000
OK.

271
00:42:32,000 --> 00:42:43,000
Most of them, I think though, are primarily caught at run time, and that's a little bit of a pain because you don't see it until you go and run the code, and there are some, actually we're going to see an example I think in a second where you find it, but you do get some help there.

272
00:42:43,000 --> 00:42:49,000
The problem is, things that you catch here are actually the least worrisome bugs.

273
00:42:49,000 --> 00:42:55,000
They're easy to spot, you can't run the program with them there, so you're not going to get weird answers.

274
00:42:55,000 --> 00:42:59,000
Not everything is going to get caught in static semantics checking.

275
00:42:59,000 --> 00:43:03,000
Some things are going to slide through, and that's actually a bother.

276
00:43:03,000 --> 00:43:04,000
It's a problem.

276
00:43:04,000 --> 00:43:16,000
Because it says, your program will still give you a value, but it may not be what you intended, and you can't always tell, and that may propagate it's way down through a whole bunch of other computations before it causes some catastrophic failure.

277
00:43:16,000 --> 00:43:21,000
So actually, the problem with static semantics is you'd like it to catch everything, you don't always get it.

278
00:43:21,000 --> 00:43:23,000
Sadly we don't get much help here.

278
00:43:23,000 --> 00:43:25,000
Which is where we'd like it.

278
00:43:25,000 --> 00:43:27,000
But that's part of your job.

278
00:43:27,000 --> 00:43:27,000
OK.

278
00:43:27,000 --> 00:43:45,000
What happens if you actually have something that's both syntactically correct, and appears to have correct static semantics, and you run it? It could run and give you the right answer, it could crash, it could loop forever, it could run and apparently give you the right answer.

279
00:43:45,000 --> 00:43:47,000
And you're not always going to be able to tell.

279
00:43:47,000 --> 00:43:54,000
Well, you'll know when it crashes, that doesn't help you very much, but you can't always tell whether something's stuck in an infinite loop or whether it's simply taking a long time to compute.

280
00:43:54,000 --> 00:43:58,000
You'd love to have a system that spots that for you, but it's not possible.

281
00:43:58,000 --> 00:44:02,000
And so to deal with this last one, you need to develop style.

282
00:44:02,000 --> 00:44:19,000
All right? Meaning, we're going to try to help you with how to develop good programming style, but you need to write in a way in which it is going to be easy for you to spot the places that cause those semantic bugs to occur.

283
00:44:19,000 --> 00:44:20,000
All right.

283
00:44:20,000 --> 00:44:23,000
If that sounds like a really long preamble, it is.

283
00:44:23,000 --> 00:44:24,000
Let's start with Python.

283
00:44:24,000 --> 00:44:47,000
But again, my goal here is to let you see what computation's about, why we need to do it, I'm going to remind you one last time, our goal is to be able to have a set of primitives that we combine into complex expressions, which we can then abstract to treat as primitives, and we want to use that sequence of instructions in this flow of control computing, in order to deduce new information.

284
00:44:47,000 --> 00:44:50,000
That imperative knowledge that we talked about right there.

284
00:44:50,000 --> 00:45:02,000
So I'm going to start today, we have about five or ten minutes left, I think, in order-- sorry, five minutes left-- in order to do this with some beginnings of Python, and we're going to pick this up obviously, next time, so; simple parts of Python.

285
00:45:02,000 --> 00:45:06,000
In order to create any kinds of expressions, we're going to need values.

286
00:45:06,000 --> 00:45:07,000
Primitive data elements.

286
00:45:07,000 --> 00:45:16,000
And in Python, we have two to start with; we have numbers, and we have strings.

287
00:45:16,000 --> 00:45:18,000
Numbers is what you'd expect.

287
00:45:18,000 --> 00:45:21,000
There's a number.

287
00:45:21,000 --> 00:45:21,000
There's another number.

287
00:45:21,000 --> 00:45:33,000
All right? Strings are captured in Python with an open quote and some sequence of characters followed by a closed quote.

288
00:45:33,000 --> 00:45:40,000
Associated with every data type in Python is a type, which identifies the kind of thing it is.

289
00:45:40,000 --> 00:45:41,000
Some of these are obvious.

289
00:45:41,000 --> 00:45:44,000
Strings are just a type on their own.

289
00:45:44,000 --> 00:45:47,000
But for numbers, for example, we can have a variety of types.

290
00:45:47,000 --> 00:45:50,000
So this is something that we would call an integer, or an INT.

291
00:45:50,000 --> 00:45:57,000
And this is something we would call a floating point, or a float.

292
00:45:57,000 --> 00:45:59,000
Or if you want to think of it as a real number.

292
00:45:59,000 --> 00:46:01,000
And there's some others that we can see.

292
00:46:01,000 --> 00:46:13,000
We're going to build up this taxonomy if you like, but the reason it's relevant is, associated with each one of those types is a set of operators that expect certain types of input in order to do their job.

293
00:46:13,000 --> 00:46:16,000
And given those types of input, will get back output.

293
00:46:16,000 --> 00:46:17,000
All right.

293
00:46:17,000 --> 00:46:21,000
In order to deal with this, let me show you an example, and I hope that comes up, great.

294
00:46:21,000 --> 00:46:28,000
What I have here is a Python shell, and I'm going to just show you some simple examples of how we start building expressions.

295
00:46:28,000 --> 00:46:32,000
And this'll lead into what you're going to see next time as well as what you're going to do tomorrow.

296
00:46:32,000 --> 00:46:33,000
So.

296
00:46:33,000 --> 00:46:37,000
Starting with the shell, I can type in expressions.

296
00:46:37,000 --> 00:46:38,000
Actually, let me back up and do this in video.

296
00:46:38,000 --> 00:46:46,000
I can type in a number, I get back a number, I can type in a string, I get back the string.

297
00:46:46,000 --> 00:47:03,000
Strings, by the way, can have spaces in them, they can have other characters, it's simply a sequence of things, and notice, by the way, that the string five-- sorry, the string's digit five digit two is different than the number 52.

298
00:47:03,000 --> 00:47:05,000
The quotes are around them to make that distinction.

298
00:47:05,000 --> 00:47:07,000
We're going to see why in a second.

298
00:47:07,000 --> 00:47:11,000
What I'm doing, by the way, here is I'm simply typing in expressions to that interpreter.

299
00:47:11,000 --> 00:47:15,000
It's using its set of rules to deduce the value and print them back out.

300
00:47:15,000 --> 00:47:19,000
Things I might like to do in here is, I might like to do combinations of things with these.

301
00:47:19,000 --> 00:47:27,000
So we have associated with simple things, a set of operations.

302
00:47:27,000 --> 00:47:33,000
So for numbers, we have the things you'd expect, the arithmetics.

303
00:47:33,000 --> 00:47:35,000
And let me show you some examples of that.

303
00:47:35,000 --> 00:47:38,000
And actually, I'm going to do one other distinction here.

303
00:47:38,000 --> 00:47:44,000
What I typed in, things like-- well, let me start this way-- there's an expression.

304
00:47:44,000 --> 00:47:56,000
And in Python the expression is, operand, operator, operand, when we're doing simple expressions like this, and if I give it to the interpreter, it gives me back exactly what you'd expect, which is that value.

305
00:47:56,000 --> 00:47:59,000
OK? The distinction I'm going to make is, that's an expression.

306
00:47:59,000 --> 00:48:01,000
The interpreter is going to get a value for it.

306
00:48:01,000 --> 00:48:04,000
When we start building up code, we're going to use commands.

307
00:48:04,000 --> 00:48:05,000
Or statements.

307
00:48:05,000 --> 00:48:09,000
Which are actually things that take in a value and ask the computer to do something with it.

308
00:48:09,000 --> 00:48:17,000
So I can similarly do this, which is going to look strange because it's going to give me the same value back out, but it actually did a slightly different thing.

309
00:48:17,000 --> 00:48:27,000
And notice, by the way, when I typed it how print showed up in a different color? That's the Python saying, that is a command, that is a specific command to get the value of the expression and print it back out.

310
00:48:27,000 --> 00:48:33,000
When we start writing code, you're going to see that difference, but for now, don't worry about it, I just want to plant that idea.

311
00:48:33,000 --> 00:48:33,000
OK.

311
00:48:33,000 --> 00:48:39,000
Once we've got that, we can certainly, though, do things like this.

312
00:48:39,000 --> 00:48:42,000
Notice the quotes around it.

312
00:48:42,000 --> 00:48:49,000
And it treats it as a string, it's simply getting me back the value of that string, 52 times 7, rather than the value of it.

313
00:48:49,000 --> 00:48:52,000
Now, once we've got that, we can start doing things.

313
00:48:52,000 --> 00:48:57,000
And I'm going to use print here-- if I could type, in order to just to get into that, I can't type, here we go-- in order to get into the habit.

314
00:48:57,000 --> 00:49:00,000
I can print out a string.

314
00:49:00,000 --> 00:49:11,000
I can print out-- Ah!-- Here's a first example of something that caught one of my things.

315
00:49:11,000 --> 00:49:15,000
This is a static semantic error.

315
00:49:15,000 --> 00:49:18,000
So what went on here? I gave it an expression that had an operand in there.

316
00:49:18,000 --> 00:49:21,000
It expected arithmetic types.

316
00:49:21,000 --> 00:49:23,000
But I gave two strings.

316
00:49:23,000 --> 00:49:26,000
And so it's complaining at me, saying, you can't do this.

316
00:49:26,000 --> 00:49:30,000
I don't know how to take two strings and multiply them together.

317
00:49:30,000 --> 00:49:37,000
Unfortunately-- now John you may disagree with me on this one-- unfortunately in Python you can, however, do things like this.

318
00:49:37,000 --> 00:49:49,000
What do you figure that's going to do? Look legal? The string three times the number three? Well it happens to give me three threes in a row.

319
00:49:49,000 --> 00:49:50,000
I hate this.

319
00:49:50,000 --> 00:49:51,000
I'm sorry, John, I hate this.

319
00:49:51,000 --> 00:49:56,000
Because this is overloading that multiplication operator with two different tasks.

320
00:49:56,000 --> 00:49:58,000
It's saying, if you give me two numbers, I'll do the right thing.

321
00:49:58,000 --> 00:50:05,000
If you give me a number and a string, I'm going to concatenate them together, it's really different operations, but nonetheless, it's what it's going to do.

322
00:50:05,000 --> 00:50:12,000
STUDENT: [UNINTELLIGIBLE] PROFESSOR ERIC GRIMSON: There you go.

323
00:50:12,000 --> 00:50:20,000
You know, there will be a rebuttal phase a little later on, just like with the political debates, and he likes it as a feature, I don't like it, you can tell he's not a Lisp programmer and I am.

324
00:50:20,000 --> 00:50:21,000
All right.

324
00:50:21,000 --> 00:50:22,000
I want to do just a couple more quick examples.

324
00:50:22,000 --> 00:50:23,000
Here's another one.

324
00:50:23,000 --> 00:50:28,000
Ah-ha! Give you an example of a syntax error.

325
00:50:28,000 --> 00:50:31,000
Because 52A doesn't make sense.

325
00:50:31,000 --> 00:50:35,000
And you might say, wait a minute, isn't that a string, and the answer's no, I didn't say it's a string by putting quotes around it.

326
00:50:35,000 --> 00:50:38,000
And notice how the machine responds differently to it.

326
00:50:38,000 --> 00:50:44,000
In this case it says, this is a syntax error, and it's actually highlighting where it came from so I can go back and fix it.

327
00:50:44,000 --> 00:50:45,000
All right.

327
00:50:45,000 --> 00:50:48,000
Let's do a couple of other simple examples.

327
00:50:48,000 --> 00:50:50,000
All right? I can do multiplication.

328
00:50:50,000 --> 00:50:51,000
I've already seen that.

328
00:50:51,000 --> 00:50:52,000
I can do addition.

328
00:50:52,000 --> 00:50:54,000
Three plus five.

328
00:50:54,000 --> 00:50:59,000
I can take something to a power, double star, just take three to the fifth power.

329
00:50:59,000 --> 00:51:04,000
I can do division, right? Whoa.

330
00:51:04,000 --> 00:51:16,000
Right? Three divided by five is zero? Maybe in Bush econom-- no, I'm not going to do any political comments today, I will not say that, all right? What happened? Well, this is one of the places where you have to be careful.

331
00:51:16,000 --> 00:51:19,000
It's doing integer division.

331
00:51:19,000 --> 00:51:23,000
So, three divided by five is zero, with a remainder of three.

332
00:51:23,000 --> 00:51:24,000
So this is the correct answer.

332
00:51:24,000 --> 00:51:30,000
If I wanted to get full, real division, I should make one of them a float.

333
00:51:30,000 --> 00:51:35,000
And yes, you can look at that and say, well is that right? Well, up to some level of accuracy, yeah, that's .6 is

334
00:51:35,000 --> 00:51:36,000
what I'd like to get out.

334
00:51:36,000 --> 00:51:38,000
All right.

334
00:51:38,000 --> 00:51:40,000
I can do other things.

334
00:51:40,000 --> 00:51:46,000
In a particular, I have similar operations on strings.

334
00:51:46,000 --> 00:51:53,000
OK, I can certainly print out strings, but I can actually add strings together, and just as you saw, I can multiply strings, you can kind of guess what this is going to do.

335
00:51:53,000 --> 00:51:58,000
It is going to merge them together into one thing.

335
00:51:58,000 --> 00:52:05,000
I want-- I know I'm running you slightly over, I want to do one last example, it's, I also want to be able to do, have variables to store things.

336
00:52:05,000 --> 00:52:20,000
And to do that, in this it says, if I have a value, I want to keep it around, to do that, I can do things like this.

337
00:52:20,000 --> 00:52:35,000
What does that statement do? It says, create a name for a variable-- which I just did there, in fact, let me type it in-- mystring, with an equal sign, which is saying, assign or bind to that name the value of the following expression.

338
00:52:35,000 --> 00:52:39,000
As a consequence, I can now refer to that just by its name.

339
00:52:39,000 --> 00:52:51,000
If I get the value of mystring, there it is, or if I say, take mystring and add to it the string, mylastname, and print it back out.

340
00:52:51,000 --> 00:52:53,000
So this is the first start of this.

340
00:52:53,000 --> 00:52:57,000
What have we done? We've got values, numbers and strings.

341
00:52:57,000 --> 00:52:59,000
We have operations to associate with them.

341
00:52:59,000 --> 00:53:00,000
I just threw a couple up here.

341
00:53:00,000 --> 00:53:08,000
You're going to get a chance to explore them, and you'll see not only are there the standard numerics for strings, there are things like length or plus or other things you can do with them.

342
00:53:08,000 --> 00:53:11,000
And once I have values, I want to get a hold of them so I can give them names.

343
00:53:11,000 --> 00:53:12,000
And that's what I just did when I bound that.

343
00:53:12,000 --> 00:53:20,000
I said, use the name mystring to be bound to or have the value of Eric, so I can refer to it anywhere else that I want to use it.

344
00:53:20,000 --> 00:12:59,000
And I apologize for taking you over, we'll come back to this next time, please go to the website to sign up for recitation for tomorrow.

