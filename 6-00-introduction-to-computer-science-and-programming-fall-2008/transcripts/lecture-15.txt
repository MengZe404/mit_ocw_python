0:00 | OPERATOR: The following content is provided under a
0:01 | Creative Commons license.
0:03 | Your support will help MIT OpenCourseWare continue to
0:06 | offer high quality educational resources for free, To make a
0:10 | donation or view additional materials from hundreds of MIT
0:14 | courses, visit MIT OpenCourseWare at ocw.mit.edu.
0:19 | PROFESSOR: Last time, Professor Guttag introduced
0:24 | the idea of objects and classes and this wonderful
0:28 | phrase called object-oriented programming.
0:31 | And it's a topic I want to pick up on today, we're going
0:33 | to do for the next few lectures, and it's a topic I
0:36 | want to spend some time on because this idea of capturing
0:41 | data and methods, the term we're going to use for it, but
0:44 | data and functions that belong to that data, things that can
0:46 | be used to manipulate them, is a really powerful one.
0:50 | What we're really getting at is the idea of saying I want
0:53 | to have a way of grouping together information into
0:57 | units that make sense.
0:58 | So I can go back to one of those topics we had at the
1:00 | beginning, which is the idea of abstraction, that I can
1:03 | create one of those units as a simple entity, bury away the
1:07 | details and write really modular code.
1:09 | And so we're going to talk about that a
1:11 | lot as we go along.
1:13 | What we're really doing, or I shouldn't say what we're
1:15 | really doing, a basic piece of what we're doing, when we talk
1:18 | about classes or objects, is we're doing something that
1:21 | Professor Guttag mentioned, we're defining an
1:23 | abstract data type.
1:26 | Now what in the world does that mean?
1:28 | Well basically what we're doing is we're giving
1:30 | ourselves the ability to create data types the same way
1:32 | that we have some built-ins, so we have things like int,
1:35 | float, string, these are built-in data types.
1:39 | And if you think about it, associated with each one of
1:41 | those data types is a set of functions it's
1:44 | intended to apply to.
1:46 | Sometimes the functions -- sometimes a function can be
1:49 | used on multiple data types, plus, for example, we saw
1:53 | could add strings, or could add ints, but each one of
1:55 | those data types has associated with it a set of
1:58 | functions that are geared to handling them.
2:00 | We want to do the same thing, but with our data types.
2:03 | We want to create data types and functions, or we're going
2:06 | to call them methods, that are specifically aimed at
2:09 | manipulating those kinds of objects.
2:11 | And our goal is then to basically see how we can build
2:14 | systems that take advantage of that modularity.
2:18 | Right, so the fundamental idea then, is, I want to glue
2:20 | together information, I want to take pieces of data that
2:23 | naturally belong together, glue them together, and attach
2:25 | some methods to it.
2:27 | And that's, you know, saying a lot of words, let's do an
2:30 | example because it's probably easiest to see this by looking
2:32 | at a specific example.
2:34 | So here's the example I'm going to start with.
2:38 | Suppose I want to do little piece of code that's going to
2:45 | do planar geometry, points in the plane.
2:48 | All right, so I want to have some way of gluing those
2:50 | things together.
2:51 | Well you know what a point is, it's got an x- and a y-
2:53 | coordinate, it's natural to think about those two things
2:55 | as belonging as a single entity.
2:58 | So an easy way to do this would be to say, let's just
3:00 | represent them as a list. Just as a 2-list,
3:06 | or a list of 2 elements.
3:08 | It's easy to think of a point as just a list of an x- and a
3:10 | y- coordinate.
3:12 | OK, for example, I might say point p1 is that list, x is 1,
3:23 | y is 2. in fact, if I draw a little simple -- it's
3:33 | basically pointing to that point in the plane, right, x
3:35 | is 1, y is 2.
3:37 | OK, fine, there's another way to represent points on the
3:41 | plane now, and that's in polar form, so this, if
3:44 | you like, is Cartesian.
3:48 | Another way to represent a point in a plane is I've got a
3:50 | radius and I've got an angle from the x-axis, right, and
3:53 | that's a standard thing you might do.
3:55 | So I might define, for example, in polar form p 2,
4:00 | and let me see, which example did I do here, we'll make this
4:08 | the point of radius 2 and at angle pi by 2, I'm going to
4:10 | make it easy because pi by 2 is up along this axis, and
4:14 | that's basically that point.
4:17 | Ok, just fine, it's no big deal.
4:22 | But here now becomes the problem.
4:23 | I've glued things together but just using a list. Suppose I
4:27 | hand you one of these lists.
4:30 | How do you know which kind it is?
4:32 | How do you know whether it's in Cartesian
4:33 | form or in polar form?
4:36 | You have nothing that identifies that there, you
4:38 | have no way of saying what this grouping actually means.
4:41 | Right, and just to get a sense of this, let's look at a
4:43 | simple little example, so on your hand-out, you'll see I've
4:47 | got a little piece of code that says assuming I've got
4:50 | one of these points, I want to do things with it, for example
4:52 | I might want to add them together.
4:53 | So this first little piece of code right here says, ok you
4:57 | give me 2 points, I'll create another 1 of these lists and
5:01 | I'll simply take the x, sorry I shouldn't say x, I'm going
5:03 | to assume it's the x, the x-values are the two points,
5:06 | add them together, just right there, the y-values, add them
5:09 | together and return that list. And if I actually run this,
5:13 | which I'm going to do -- excuse me, do it again --
5:19 | OK, you can see that I've added together and I've
5:21 | printed out the value of r, and I'll just show you that in
5:23 | fact that's what I've got.
5:24 | This looks fine, right, I'm doing the right thing.
5:29 | Another way of saying it is, I've actually said, what did I
5:32 | use there, (1,2) and (3,1), It's basically saying there is
5:41 | the first point, there's the second point, add them
5:42 | together and I get that point.
5:45 | OK, that sounds fine.
5:49 | Now, suppose in fact these weren't x and y glued
5:52 | together, these were radius and angle glued together.
5:55 | In that case point p 1 doesn't correspond to this point, it
6:02 | actually corresponds to the point of radius 2 and angle 1,
6:05 | which is about here.
6:07 | I think I wrote this down carefully so I would make sure
6:11 | I did it right.
6:13 | Sorry, said that wrong, radius 1 and angle 2, 2 radians is a
6:17 | little bit more than pi half.
6:19 | And the second point is of radius 3 and angle 1, which is
6:25 | up about there.
6:30 | So what point, sorry, bad pun, what point am I
6:32 | trying to make here?
6:34 | Different understandings of what that piece means gives
6:38 | you different values, and that's a bit of a problem.
6:42 | The second problem is, suppose actually I had p 1 and p 2
6:45 | were in polar form, and I ran add points on them.
6:49 | This little piece of code here that I did.
6:52 | Does that even make any sense?
6:55 | Course not, right?
6:55 | You know when you add 2 polar forms, you add the radii
6:58 | together, you don't add the angles together, you need to
7:00 | do it in Cartesian form.
7:02 | So what I'm leading up to here is that we've got a problem.
7:06 | And the problem is, that we want to build this abstract
7:10 | data type, but we'd like to basically know what kind of
7:12 | object is it, and what functions actually belong to
7:16 | it, how do we use them?
7:17 | And so I'm going to go back to this idea of a class, and
7:19 | let's build the first of these, and that is shown right
7:21 | here on this piece of your handout.
7:25 | I'm going to define a class, and in particular, what I'm
7:29 | going to do, is walk through what that says.
7:33 | So I'm going to now build an object, it's going to
7:37 | represent a point.
7:43 | So what does that thing say up there?
7:44 | It's got this funky looking form, right, it says, I've got
7:47 | something that I'm going to call a class, got that key
7:52 | word class right here.
7:56 | And I'm going to give it a name, and right now I'm just
7:58 | building a simple piece of it -- but first of all, what does
8:00 | a class do?
8:01 | Think of this as, this is a template for creating
8:11 | instances of an object.
8:19 | At the moment, it's a really dumb template.
8:22 | I'm going to add to it in a second, but I want
8:23 | to build up to this.
8:24 | Right now it's got that second key word there called pass,
8:27 | which is just Python's way of saying there's an
8:29 | empty body in here.
8:31 | Right,, we're going to add to it in a second, but the idea
8:33 | is class is going to be a template
8:35 | for creating instances.
8:37 | How do I use it?
8:39 | Well, I call class just like a function, and you
8:41 | can see that below.
8:42 | Having created this thing called Cartesian point, I'm
8:45 | going to create two instances of it. c p 1 and c p 2.
8:49 | Notice the form of it, it's just the name of the class
8:51 | followed by open paren, close paren,
8:53 | treating it like a function.
8:56 | What that does, is that it creates, c p 1 and c p 2 are
9:03 | both instances of this type, specific
9:12 | versions of this type.
9:15 | For now the way to think about this is, when I call that
9:17 | class definition, it goes off and allocates a specific spot
9:22 | in memory that corresponds to that instance.
9:25 | Right now it's empty, actually it's not quite empty, it has a
9:27 | pointer back to the class.
9:28 | And I can give a name to that, so c p 1 and c p 2 are both
9:32 | going to point to that.
9:34 | Once I've got that, I can now start giving some variable
9:37 | names, sorry not, rephrase that, I can give some
9:39 | attributes, I can give some
9:41 | characteristics to these classes.
9:43 | So each instance has some internal, or will have some
9:50 | internal attributes.
9:58 | Notice how I did that up there.
10:00 | Having created c p 1 and c p 2, I had this weird
10:05 | looking form here.
10:06 | Not so weird, you've actually seen it before.
10:08 | In which I said c p 1 dot x equals 1.0.
10:15 | What's this doing? c p 1 points to an instance, it
10:19 | points to a particular version of this class.
10:23 | And I have now given an internal variable name x and a
10:27 | value associated with that.
10:29 | So I've just given it an x variable.
10:31 | All right, c p 1 dot y, I've said assign that to
10:34 | the value 2, 2,0.
10:37 | So now c p 1 has inside of it an x and y value.
10:42 | Did the same thing with c p 2, give it a
10:44 | different x and y value.
10:46 | Again, remind you, c p 2 is a different instance
10:49 | of this data type.
10:51 | All right, when I call the class definition it goes off
10:53 | and finds another spot in memory, says that the spot I'm
10:56 | going to give you a pointer back to that, give it the name
10:58 | c p 2, and then by running these 2 little assignments
11:02 | statements here, I've given it an x and a y value for c p 2.
11:08 | So you see why I say it's a template, right?
11:10 | Right now it's a simple template, but it's a template
11:12 | for creating what a class looks like, and I now have an
11:14 | x- and y- value associated with each instance of this.
11:18 | OK, and if I wanted to look at it, we can come back over
11:20 | here, and we can see what does c p 1 look like, interesting.
11:28 | It says some funky stuff, and says it's a kind
11:31 | of Cartesian point.
11:33 | And that's going to be valuable to me when I want to
11:35 | get back to using these things, right?
11:36 | You see that little thing says dot Cartesian point in there.
11:39 | If I want to get out right now the versions of these things,
11:42 | I can ask what's the value of c p 1 x, and it
11:46 | returns it back out.
11:48 | I could say c p 2 dot x, that was a bad one to use because
11:52 | they use the same valuable in both places, didn't I?
11:54 | So let's do c p 1 dot y, c p 2 dot y.
12:01 | OK, so I've just created local versions of variables with
12:04 | each one of these objects.
12:05 | I can get at them just like I would before, I can assign
12:08 | them in as I might have done before.
12:12 | OK, now that I've got that, we could think about what would I
12:16 | want to do with these points?
12:18 | Well one thing I might want to do is say, is this the same
12:20 | point or not?
12:22 | So the next little piece of code I've written here, just
12:25 | move down to it slightly.
12:30 | I've got a little piece of code called same point.
12:33 | And you can look at it.
12:35 | What does it say to do?
12:36 | It says, if you give me two of these data objects, I'm going
12:39 | to call them p 1 and p 2.
12:42 | I'm going to say, gee, is the x value the same in both of
12:45 | them, and if it is, and the y value's the same, then this is
12:50 | the same point, I'm going to return true.
12:53 | Notice the form.
12:54 | This is saying, that's a class, or sorry, an instance
12:58 | of a class, and I'm going to get the x value
13:00 | associated with it.
13:02 | I going to come back in a second to how it actually does
13:04 | that, but it basically says, get me x value for p 1, get me
13:07 | the x value for p 2, compare them, just
13:08 | as you would normally.
13:10 | I've got another little thing here that I'm going to use a
13:12 | little later on that just prints out values of things.
13:16 | OK, let's see what happens if I do this.
13:21 | Let me show you simple little example.
13:22 | I'm going to go over here, and let me define a couple of
13:29 | these things.
13:30 | I'm going to say p 1, try it again, p 1 is a Cartesian, it
13:42 | would help if I could type, Cartesian point, and I'm going
13:49 | to say p 1 of x is 3, p 1 of y is 4, and I'm going to make p
13:56 | 2 another Cartesian point.
14:03 | And I'll give it an x value of 3 and a y value of 4.
14:12 | OK, now I want to say, are these the same?
14:15 | Thing I've got a little procedure that could do that,
14:18 | but you know the simplest thing I could do is to say
14:20 | well, gee, wait a minute, why don't I just check to see if
14:22 | these are the same thing?
14:23 | So I can say is p 1 the same as p 2, using Scheme's
14:29 | built-in is comparator.
14:30 | Say -- sorry?
14:32 | PROFESSOR 2: Part of Python?
14:33 | PROFESSOR: Part of Scheme, whoa, there's a Freudian slip,
14:35 | thank you, John.
14:36 | I'm showing my age, and my history here, is p 1 and p 2
14:40 | the same thing?
14:41 | Hey, there's a bad English sentence even worse, now I'm
14:43 | really thrown off.
14:43 | I'm using Python's is comparator to say is it the
14:45 | same thing?
14:46 | It says no.
14:50 | But if I say, are p 1 and p 2 the same point, it says yes.
15:00 | And this is a point I want to stress here.
15:02 | So what's going on in this case is, I want to distinguish
15:04 | between shallow equality and deep equality.
15:18 | The first thing is testing shallow equality.
15:23 | What it is doing, that's another bad English sentence,
15:26 | but what it is doing?
15:27 | Is is essentially saying, given 2 things, do they point
15:32 | to exactly the same referent?
15:34 | Or another way of thinking about it, is remember I said
15:37 | when I call that class definition it creates an
15:39 | instance, that's a pointer to some spot in memory that's got
15:41 | some local information around it.
15:43 | Is is saying, do these things point to exactly the same spot
15:46 | in memory, the same instance.
15:49 | Deep equality, we get to define, that's what I did by
15:56 | writing same point.
15:57 | OK, as I said, I want equality in the case of points to be,
16:00 | are the x- and y- coordinates the same?
16:02 | And I'm actually going to change it. just to show you
16:05 | this point.
16:06 | If I do the following, and I say, I'm going to
16:12 | assign p 1 to be p 2.
16:14 | What's that doing?
16:15 | It's taking the name p 1 and it's changing its value to
16:18 | point to exactly what p 2 points to.
16:21 | And then I say, are they the same thing?
16:25 | Answer's yes, because now they are pointing to exactly the
16:28 | same spot in memory.
16:30 | The same instance.
16:32 | OK, the reason I'm saying this is, we have one class
16:34 | definition, is a cookie cutter, it's a template that's
16:36 | going to let us build versions of these things.
16:38 | Every time I use it, I'm creating a new instance,
16:40 | that's a different thing inside of memory.
16:43 | And I want to have that because I want to have lots of
16:45 | versions of points.
16:47 | OK, now, let's go back to where I was.
16:54 | I said one of the things I want to do is, I want to have
16:56 | different versions of points.
16:57 | So I've got now things that are Cartesian points.
17:00 | I could do the same thing, I could build polar point.
17:03 | I wanted to show it to you here.
17:04 | I've got a class called polar point, which is right there,
17:07 | and same kind of thing, I can create instances of it, and
17:10 | then assign to them things like a radius and an angle,
17:13 | make instances of those.
17:15 | OK, John?
17:18 | PROFESSOR 2: I just want to maybe mention that in some of
17:21 | the reading, you'll see terms like object equality and value
17:21 | equality, instead of shallow equality and deep equality.
17:26 | PROFESSOR: Right, so, this object, this is,
17:33 | right, value quality.
17:35 | Right.
17:36 | And you will see both terms used.
17:37 | Some people like to use shallow and deep, object and
17:39 | value, but they're talking about the same thing, which is
17:41 | it the same object or is it the same, in this case, set of
17:44 | values, depending on what you want to define as you use it.
17:49 | OK, so as I said, now I can go off and I could create a
17:57 | different class.
17:57 | I've got Cartesian points, I could create a polar points.
18:00 | And I'm going to run it in a sec, but you can see, the same
18:02 | kind of idea.
18:02 | I define a class call polar point, I create a couple of
18:05 | them, and I give them a radius and an angle.
18:07 | And then I could do things like again, say, okay having
18:10 | done, that let me just run it here, run that, so I've now
18:17 | got polar point 1, and polar point 2.
18:19 | I can say is polar point 1 the same as polar point 2, and the
18:23 | answer should be no.
18:25 | And then I could say well, gee, are they the same point?
18:30 | Oops.
18:38 | What happened?
18:40 | Well it bombed out.
18:41 | Because, what was I expecting to do?
18:43 | I was expecting to compare x- and y- values,
18:45 | not radius and angle.
18:47 | And so this doesn't know how to do it, it doesn't have a
18:49 | method to deal with it, so it complains.
18:52 | So what's my problem here, and this is what I want to now
18:54 | lead up to.
18:55 | I could imagine writing another function for same
18:59 | point, and I have to give it a name like same point polar,
19:01 | and same point Cartesian.
19:03 | A different function to compare polar versions of
19:05 | these points.
19:07 | But that's starting to get to be a nuisance.
19:09 | What I'd really like to do is to have 1 representation for a
19:13 | point that supports different ways of getting information
19:17 | out, but has gathered within it, a method or a function for
19:20 | dealing with things like how do I know if it's the same
19:22 | point or not.
19:23 | So I want to take this idea classes now, and I want to
19:26 | generalize it.
19:28 | Right, and that is going to lead us then to this funky
19:32 | looking thing.
19:34 | Right there, and I'd like you to look at
19:36 | that in your handout.
19:38 | OK, I'm going to go back and rebuild the class.
19:44 | Ok, and again, I'm going to remind you, the
19:45 | class is this template.
19:50 | But now I'm going to change it, so what is that new
19:52 | version of class say.
19:54 | I'm going to call it c point just to
19:55 | make it a little shorter.
19:56 | You can see inside of it, it's got a set of definitions for
20:00 | things like functions.
20:01 | And that first one is this kind of interesting thing,
20:04 | it's two underbars, init, and two underbars.
20:09 | Underscores, I guess is the right way
20:11 | to say it, not underbars.
20:13 | Right that's a specific name, and what it basically says is,
20:17 | when I call the class instance.
20:20 | That's a bad mistake.
20:22 | When I call the class definition, that is I call c
20:25 | point, I'm going to call it with a
20:29 | specific set of arguments.
20:31 | And what is it going to happen is that init is
20:34 | going to then apply.
20:36 | It's going to apply to those arguments.
20:38 | So let me in fact show you an example.
20:40 | I've got a definition of Cartesian point, I've got a
20:43 | definition of polar point.
20:46 | Let me just run these to get them in there.
20:51 | Now let's do the following.
20:52 | Let's let p be Cartesian point, and we'll give it a
21:01 | couple of values.
21:03 | OK?
21:06 | So what happened?
21:06 | Notice in the class definition here, is there, this is the
21:11 | first thing that's got called, and I just called with the
21:12 | value for x and the value for y, and it went off and did
21:16 | something for me.
21:18 | Does that look right?
21:25 | This is where you all hate it, I get no eye contact anywhere.
21:28 | Anything look odd about that?
21:30 | I said.
21:31 | When I call this class definition, it calls init, and
21:33 | I give it an x and a y value.
21:38 | How many arguments does init take?
21:40 | Three.
21:41 | How many arguments did I give it?
21:43 | Two.
21:44 | What in the world's going on?
21:47 | Well, this is a piece of object-oriented coding that we
21:49 | get to talk about a little bit.
21:50 | There's this weird extra variable in there called self.
21:53 | So what is self?
21:57 | And I have to admit, I did the standard thing you do every
21:59 | time you run across something you don't know about, you go
22:03 | to Wikipedia.
22:04 | So I went and looked up self in Wikipedia, and I have to
22:07 | read it out.
22:08 | Wikipedia informs us that the self is the idea of a unified
22:12 | being, which is the source of an idiosyncratic
22:14 | consciousness.
22:15 | Moreover, this self is the agent responsible for the
22:18 | thoughts and actions of an individual to
22:20 | which they are ascribed.
22:21 | It is a substance which therefore endures through
22:23 | time, thus thoughts and actions at different moments
22:26 | of time may pertain to the same self.
22:29 | OK, how do we code that up?
22:31 | Sounds like an AI problem, I guess right?
22:33 | But there's actually hidden in there an important element,
22:38 | and that is, when I create an instance, I have to be able to
22:42 | get access to the things that characterize that instance.
22:45 | I won't say that they're thoughts and emotions or
22:47 | things, but what characterizes an instance here, it's the
22:50 | internal parameters that specify what is going on.
22:54 | So in fact what happens inside of an object-oriented system,
22:57 | and particularly in Python's object-oriented
22:59 | system, is the following.
23:02 | When we call init, it's going to create the instance, all
23:14 | right, just as we said before.
23:16 | But in particular, it's going to use self to
23:29 | refer to that instance.
23:32 | Right, so let me say this a little differently.
23:36 | I have a class definition.
23:38 | It's actually an object somewhere.
23:39 | It has inside of it all those internal definitions.
23:42 | When I call that class definition, it calls init.
23:45 | Init creates a pointer to the instance.
23:48 | And then it needs to have access to that, so it calls
23:51 | it, passing in self as the pointer to the instance.
23:56 | That is, it says it has access to that piece in memory, and
23:59 | now inside of that piece of memory, I can do things like,
24:02 | as you see here, define self dot x to be the value
24:07 | passed in for x.
24:09 | What's that doing?
24:09 | It's saying where's self pointing to?
24:11 | Inside of that structure, create a variable name x, and
24:15 | a value associated with it.
24:16 | Notice what I also do here, I create self dot y, give it a
24:19 | value, and then, oh cool, I can also set up what's the
24:22 | radius and angle for this point, by just doing a little
24:27 | bit of work.
24:29 | OK, in fact if you look at what it does there, just put
24:32 | the pointer over here, it says, get the value of x that
24:36 | I just stored away, square it, add it to the value of y
24:39 | squared that I just stored away, and then take square
24:41 | root, pass it back out.
24:43 | So I just computed the radius of that particular thing.
24:45 | Right?
24:46 | Compute the angle the same way, just using the
24:47 | appropriate things.
24:49 | So the idea is that self will always point to
24:54 | the particular instance.
24:56 | Now you might say, why?
24:58 | Why do it this way?
25:00 | Well, basically because it was a design choice when the
25:03 | creators of Python decided to create the language, they
25:05 | basically said, we're always going to have an explicit
25:07 | pointer to the instance.
25:09 | Some other object-oriented programming languages do not
25:11 | provide that pointer.
25:13 | This is kind of nice in my view, I don't know if John,
25:15 | you'd agree, but this is explicit.
25:17 | It actually lets you see how to get access to that pointer
25:19 | so you know what you're referring to.
25:21 | But it's simply design choice.
25:23 | So another way saying it again is, when I call the class
25:26 | definition, by default I'm going to look to see is there
25:28 | an init method there, and if there is, I'm going to use it.
25:31 | First argument by convention is always self, because it has
25:35 | to point to the instance, and then I pass, in this case,
25:37 | another couple of arguments in.
25:39 | OK, now, if I actually do this, and I'm going to show
25:43 | you the example, I just, what did I type over there, I got p
25:46 | was a c point.
25:48 | If I want to get values back out, I could in fact simply
25:52 | send to that instance a message, in this case I could
25:55 | say p dot x.
25:58 | In fact let's do it.
26:00 | If I do that over here -- aha -- it gets me back the value.
26:08 | Now let me spend just a second to say, what was this actually
26:10 | doing? p is an instance.
26:13 | It knows, or has stored away, and in fact let's look at it,
26:16 | if we look at what p does, p says -- it says reading
26:22 | through a little bit of this stuff here, it says -- it's a
26:25 | kind of Cartesian point, it's an instance, there's actually
26:28 | the memory location that it's at, that's why I say this idea
26:31 | of it's an instant at a specific spot.
26:34 | It knows that it came from this class, c point.
26:38 | So when I type, I'm sorry, I shouldn't say type, when I
26:41 | write, although I would have typed it, p dot x, here's what
26:44 | basically happens. p is an instance, it's being sent a
26:48 | message, in this case the message x, it says I want the
26:50 | x-value back out. p knows that it is a kind of Cartesian
26:55 | point, it actually goes and gets, if you like, the class
27:00 | definition up here.
27:04 | And is able to then say, inside of that class
27:06 | definition, find the value of x.
27:09 | All right, now, that's one of the ways we could get things
27:13 | out, but in fact it's really not a good way.
27:15 | A better way to do this would be the following.
27:20 | If I could type.
27:27 | What did I just do there?
27:29 | One of the things that I defined inside my class
27:31 | definition here was an internal method.
27:36 | That method has a name, obviously, and
27:39 | what does it do?
27:39 | It's going to go off and get the values of x and y attached
27:42 | to this thing and return them to me.
27:45 | And that's one of the things I want.
27:46 | I would like my classes to have methods.
27:57 | So you can access the values of the specific instance.
28:09 | Now, this is still a nuance, why would I like to do this?
28:11 | Well this is leading up to why I want to gather things
28:14 | together in classes to start with.
28:16 | It's perfectly legal in Python to type that in and get the
28:20 | value back out.
28:21 | As I said, I would prefer to do something that uses an
28:23 | accessor that I just wrote.
28:28 | So p dot Cartesian is a kind of accessor, it's getting
28:35 | access to the data.
28:39 | And here's why I'd like to have it.
28:42 | Right now, I still have the problem that those classes,
28:45 | those instances of classes, are exposed.
28:47 | What do I mean by that?
28:48 | Here's something I could do.
28:57 | Let's do it in fact.
29:07 | OK.
29:09 | What point in the plane does p now point to?
29:13 | X-axis is foobar y-axis ought to be foobass
29:16 | something else, right?
29:18 | I know it looks like a simple and silly little example, but
29:21 | at the moment, I still have the ability to go in and
29:24 | change the values of the parameters by that little
29:27 | definition.
29:28 | And this makes no sense.
29:29 | And this is because I don't have something I would really
29:32 | like to have, which is data hiding.
29:40 | So you'll see lots of definitions of this.
29:42 | I think of data hiding as basically saying, one can only
29:49 | access instance values, or, we'll call them that, instance
29:54 | values through defined methods.
30:06 | And that's a wonderful thing to have because it gives you
30:08 | that modularity, that encapsulation that basically
30:11 | says, when I create a point, the only way I can get at the
30:14 | values, is by using one of the defined methods, in this case
30:17 | it could be Cartesian, and get all the pieces of that.
30:20 | Unfortunately, Python doesn't do this.
30:28 | Which is really a shame.
30:30 | Or another way of saying it is, please don't do that.
30:34 | Don't go in and change the values of things by using the
30:37 | direct access.
30:38 | Have the computational hygiene, if you like, to only
30:41 | go through accessors, only go through methods that are
30:44 | actually provided to you as you do this.
30:46 | I actually don't remember, John, C++ does have data
30:51 | hiding, I think, right?
30:52 | PROFESSOR 2: And not only shouldn't you change it, you
30:57 | shouldn't even read it.
30:58 | PROFESSOR: Exactly.
30:58 | What you're going to see in a second I violated in some of
31:00 | my code, which Professor Guttag is going to yell at me
31:02 | shortly because I should have done it through accessors,
31:04 | but, he's exactly right.
31:06 | A good, hygienic way of doing this is, not only do I not go
31:09 | in and change things except through a pre-defined method,
31:11 | I shouldn't read it other than through a pre-defined method.
31:13 | I should use Cartesian or polar to pull out
31:16 | those pieces of it.
31:23 | Once I've got that, you notice I can now define a polar
31:28 | point, same way.
31:30 | Notice I've now solved one of my problems, which is, in each
31:33 | one of these cases here, I'm creating both x y and radius
31:38 | angle values inside of there.
31:40 | If it's in polar form I passed in a radius and angle and I'll
31:43 | compute what the x- and y- value is.
31:46 | If its in Cartesian form I'll pass in an x and y and compute
31:48 | what a radius and angle is.
31:50 | But it now says that in any, in no matter what kind of form
31:53 | I made it from, I can get out that kind of information.
31:56 | So for example I defined p, remember back over here, as a
32:00 | Cartesian point, but I can actually ask
32:01 | for its polar form.
32:07 | It's there accessible to me.
32:09 | OK, this is great.
32:11 | Just to drive home one more reason why I don't want to
32:14 | have changes to the values other than
32:16 | through pre-defined things.
32:18 | Notice what happens if I do the following.
32:23 | I could say I want to change the radius of
32:26 | this particular thing.
32:28 | OK, perfectly reasonable thing to do.
32:32 | And if I go look at the polar form of this, OK, good, looks
32:39 | right, right?
32:40 | It's now got a different radius, same angle, so I just
32:42 | changed the radius of it.
32:44 | Oh, but what happened to the Cartesian form.
32:46 | I should have done this earlier by typing the
32:47 | Cartesian form earlier, so let me go back to where I was,
32:50 | sorry for that, let me go make this a 1 again.
32:58 | If I look at the Cartesian, oh, I did have the Cartesian
33:00 | form, don't mind me while I mutter to myself here quietly.
33:05 | Yeah, that's right, I did screw that up badly.
33:07 | All right, we try one more time, here we go, let's try
33:10 | one more time.
33:12 | We'll make p a new point, ok?
33:23 | There's the Cartesian representation of it, which is
33:24 | right, (1,2).
33:26 | Here's the polar representation of it, some
33:30 | random set of numbers which makes sense.
33:33 | If I now say, I'm going to go ahead and change the radius of
33:37 | this, something, my polar form did it right, but what
33:47 | happened to the Cartesian form?
33:53 | Ah yes, didn't change.
33:56 | Which makes sense if you think of my code.
33:58 | I didn't have anything in there that says, if you change
34:00 | one of these values, other values depend on it, and I
34:03 | want to make that change to it.
34:05 | So this is one more example of stressing why I only want to
34:08 | come access to the instances through defined methods.
34:12 | Because I could've built that in, it says if you change the
34:14 | value of this thing, by the way you need to change
34:16 | recompute those other values in order to make this hold up.
34:19 | OK, so what else do I have then in my little class
34:23 | definitions here?
34:25 | So, I've got an init in both cases.
34:28 | I don't have to put an init in, but it's again, usually a
34:31 | good idea to put that in originally.
34:33 | I've got and init that says, when you create an instance,
34:34 | here's what you do.
34:36 | Notice that that typically also defines for me what the
34:39 | internal variables are, what the internal characteristics
34:42 | of the class are going to be.
34:44 | Again, I could have some other functions to compute things,
34:46 | but this is typically the place where I'm
34:47 | going to put them in.
34:48 | So this is giving me now that template, better way of saying
34:51 | it, all right, a template now, for a point is
34:53 | x, y, radius, angle.
34:55 | And I can see that in those pieces there.
34:57 | And then I've got some things that get me back out
35:00 | information about them.
35:02 | But I got a couple of other of these strange looking things
35:04 | in there with underbars to them.
35:05 | So let's look at what some of the traditional methods for
35:09 | classes are in Python.
35:11 | I have init.
35:15 | This is what's actually going to create the instance,
35:22 | instantiate it, create what the set of variable
35:24 | values are for it.
35:26 | OK, I have another one in there,
35:27 | underbar, underbar, str.
35:32 | Anybody have a sense of what that's doing?
35:38 | What's s -- sorry, I heard something, sorry go ahead.
35:41 | STUDENT: Display what I have.
35:44 | PROFESSOR: Displaying what I have. Thank you.
35:44 | Yeah, I was going to say, think about what does str do,
35:47 | in general?
35:48 | It converts things into a string type.
35:50 | How do we typically print things, we
35:52 | convert them to strings.
35:53 | So str is basically telling us how we want to
35:59 | have it printed out.
36:08 | OK, in fact if we look at this, if I say, print of p, it
36:15 | prints it out in that form.
36:16 | Now this is actually a poor way to do it, because you
36:18 | might say, well, it's just the list. But remember, it wasn't
36:20 | a list. What does it do?
36:21 | It says, if I want to print out something I built in
36:23 | Cartesian form up here, says, again, I'm going to pass it in
36:28 | a pointer to the instance, that self thing, and then I'm
36:31 | going to return a string that I combine together with an
36:34 | open and close paren, a comma in the middle, and getting the
36:38 | x-value and the y-value and converting them into strings
36:41 | before I put the whole thing together.
36:43 | So it gives me basically my printed representation.
36:46 | OK.
36:47 | What else do I have in here?
36:49 | Well, I have cmp.
36:54 | My handout's wrong, which I discovered this morning after
36:57 | I printed them all out.
36:58 | So the version I'd like you to have uses, that, greater than
37:07 | rather than equals that I had in my handout.
37:11 | What's cmp doing as a method?
37:14 | Yeah?
37:14 | STUDENT: Comparing values?
37:16 | PROFESSOR: Yeah, comparing values, right?
37:17 | And again, it's similar to what cmp would do
37:20 | generically in Python.
37:22 | It's a way of doing comparisons.
37:23 | So this is doing comparisons.
37:29 | Now, I put a version up there, I have no idea if this is the
37:31 | right way to do comparisons or not.
37:33 | I said both the x- and y- coordinates are bigger, then
37:35 | I'm going to return something to it.
37:36 | And I think in the polar one I said, if, what did I do there,
37:40 | I said, yeah, again if the x and y are greater than the
37:42 | other one, I'm going to return them to it.
37:45 | The version in the handout, what was that actually doing?
37:50 | You could look at the handout.
37:56 | Well I think it was comparing, are they the same?
38:00 | So that would actually be another method I could put in.
38:08 | Underbar underbar eq, underbar underbar.
38:11 | Would be a default or generic way of doing, are
38:14 | these things the same?
38:16 | OK, in each case, what these things are doing, is they're
38:23 | doing, what sometimes gets referred to as operator
38:32 | overloading.
38:33 | I know you don't remember that far back, but in about the
38:35 | second lecture I made a joke of Professor Guttag which, you
38:38 | know, you didn't laugh at, he didn't laugh at, that's okay.
38:40 | In which I said, you know, I didn't like the fact that
38:43 | things like plus are overloaded, because you can
38:45 | use plus to add strings, you can use plus to add numbers,
38:48 | you can use plus to add floats.
38:50 | And he quite correctly, because he's more senior than
38:52 | I am, more experienced than I am, said it's
38:54 | actually a good thing.
38:55 | And he's right.
38:57 | Most of the time.
38:59 | The reason I say that is, by having operator overloading I
39:02 | can use 1 generic interface to all of the objects
39:06 | that I want to use.
39:07 | So it makes sense to be able to say, look for many methods
39:10 | I do want to have a way of doing comparison, and I don't
39:12 | have to remember, at top level, what the name of the
39:16 | comparison method was.
39:17 | I can simply use the built-in Sc -- about to say Scheme
39:20 | again -- the built-in Python comparison operation.
39:23 | Say, are these 2 things the same?
39:25 | Same thing with cmp, that's just saying greater than, and
39:27 | greater than now can apply to strings, it can apply to
39:30 | floats, it could apply to points, it could add other
39:32 | pieces into it.
39:34 | So there are some downsides, in my view, to doing operator
39:36 | overloading, but there's some real pluses.
39:38 | And the main one is, I get to just decide, how do I want to
39:41 | use this, and call it.
39:42 | Yes, ma'am?
39:43 | STUDENT: [INAUDIBLE]
39:47 | PROFESSOR: Right, cmp other, so how would I call this?
39:52 | A good question.
39:52 | Here's the way I would call it.
39:54 | Let me give you, I'm going to create, a polar point, I'm
39:59 | going to call it q, and we'll give it some random values.
40:02 | OK, and now I want to know, is p greater than q?
40:09 | Now happens to return true here, but the question is,
40:11 | where's the other come from?
40:13 | P is a particular object type.
40:16 | When I try and evaluate that expression of greater than, is
40:19 | going to go into the class to say greater
40:22 | than is a comp method.
40:25 | So let me say it very carefully here.
40:27 | When I evaluate, yeah, when I evaluate this, p is an
40:32 | instance of a point, in this case it was actually a
40:35 | Cartesian point, it sends a message to the instance, which
40:40 | sends a message to the class, to get the cmp
40:44 | method from the class.
40:46 | And that then gets applied to itself, just p, and one other
40:51 | argument, which is the second piece there, so other points
40:55 | to the second argument that was present.
40:57 | OK.
40:59 | John?
40:59 | PROFESSOR 2: -- other, it could have said
41:02 | who or zort or --
41:03 | PROFESSOR: Yeah, sorry, that was part of the question, I
41:05 | could have a picked foobar could put anything in here.
41:07 | It's simply, notice the form of it here is, it's going to
41:11 | take two arguments, and you're right, self is
41:13 | the original instance.
41:14 | This says, I need a second argument to it, and that
41:16 | second argument better be a point so I can do the
41:18 | comparison.
41:19 | Yes ma'am?
41:20 | STUDENT: [INAUDIBLE]
41:23 | PROFESSOR: What do you think happens?
41:28 | Sorry, the question was, what happens if I said p
41:29 | is less than q?
41:31 | Got it, yes?
41:34 | Seems pretty obvious, right?
41:40 | Next time I bring the right glasses.
41:48 | It's still calling cmp, but it's knowing that cmp is just
41:51 | reversing the order of the arguments.
41:53 | Ok, which makes sense.
41:54 | If greater than takes, expects, arguments in order x
41:58 | y, less than simply takes greater than, but with the
42:01 | arguments reversed.
42:02 | OK, so I don't have to, it's a great question, I don't have
42:04 | to create a second one for cmp.
42:06 | Cmp is just saying, is this bigger than, and if I want to
42:08 | reverse it, it goes the other way.
42:10 | Question?
42:10 | STUDENT: [INAUDIBLE]
42:13 | PROFESSOR: Or equal equal?
42:17 | Let's try equal equal because I didn't define it here.
42:25 | It says they're not the same, and boy, I need help on this
42:28 | one, John, it's not, there's no pre-defined eq in there.
42:32 | PROFESSOR 2: So, what cmp does, and maybe this isn't
42:37 | exactly the right way to write is, is cmp actually returns 1
42:40 | of 3 values.
42:42 | A 0, minus a positive value, zero or a negative value,
42:48 | depending upon whether it's less than,
42:50 | equal, or greater than.
42:52 | PROFESSOR: Right.
42:52 | PROFESSOR2: So it's not really a Boolean-valued function.
42:56 | It has 3 possible values it could return.
42:59 | PROFESSOR: And so in this case, it's using the same
43:01 | piece, but it's returning that middle value that says they're
43:04 | actually the same.
43:07 | Right, one the things you can see now is, we start building
43:09 | up classes, we get these methods.
43:10 | So you can actually say, how do I know which methods are
43:13 | associated with the class?
43:14 | For that, we can call dir.
43:20 | And what it does, is it gives me back a listing of all the
43:25 | things, all the methods, that are associated with it.
43:27 | Some of which I built: cmp, init, str.
43:32 | And there, notice, are the internal definitions and there
43:35 | are the internal variables.
43:37 | And in fact I should've said, we often call
43:38 | those things fields.
43:40 | So inside of an instance, associated with an instance,
43:45 | we have both methods and fields.
43:51 | These are both altogether called
43:53 | attributes of the instance.
43:56 | And then there were a couple of other ones in there that I
43:58 | hadn't actually dealt with.
44:00 | The reason I want to point this out to you is, if we go
44:02 | back up to the kinds of data objects we started with,
44:05 | floats, ints, strings, they actually behave the same way.
44:09 | They are instances of a class, and associated with that class
44:13 | is a set of methods.
44:14 | So for example, I can say, what are all the methods
44:19 | associated with the number, or the integer 1?
44:24 | And you probably recognize some of them in there, right,
44:26 | absolute value, add, comp, cors, well we didn't do cors,
44:30 | we did a bunch of other things.
44:32 | It could also say, what are the methods associated with
44:38 | the string, 1.
44:42 | I'm sure you can quickly graph it, but notice
44:44 | they aren't the same.
44:46 | That makes sense.
44:47 | We have some set of things we want to do with strings, and
44:50 | different set of things we want to do with numbers.
44:52 | But underlying Python is the same idea.
44:54 | These are instances of a class, and associated with
44:57 | that class are a set of methods, things
44:59 | that I can deal with.
45:01 | So this is a handy way of being able to see, what are in
45:03 | fact the methods that are available if I don't happen to
45:05 | remember them, and want to go back to them.
45:08 | OK, I want to spend the last few minutes just showing you a
45:12 | couple of other things that we can do in here.
45:15 | Let me see where I want to go with this.
45:17 | So let's add one more piece to this.
45:23 | OK, now that I've got points, I might want to do something
45:26 | with points.
45:27 | So an easy thing to do in planar geometry is I want to
45:29 | make a line segment.
45:30 | It's got a start point, it's got an end point.
45:32 | Right, if you want to think of it back over here.
45:40 | There's a line segment, it's got a starting point and
45:43 | ending point.
45:44 | Well, I can do the same thing.
45:45 | And the reason I want to use this as an example is, here's
45:48 | my little definition of segment.
45:51 | Again, it's got an initializer, or an instance
45:53 | creator, right there.
45:56 | Takes a start and an end point, just going to bind
45:58 | local variable names start and end to those pieces.
46:01 | But notice now, those aren't just simple things like
46:04 | numbers, those are actually points.
46:08 | And that's where the modularity comes in.
46:09 | Now I have the ability to say, I've got a new class, I can
46:12 | create instances of a line segment, and it's elements are
46:15 | themselves instances of points.
46:19 | OK?
46:20 | And then what might I want to do with the segment?
46:21 | I might want to get the length of the segment.
46:23 | And I know it's kind of, you can see it on your handout, it
46:25 | has the rest of the pieces over here.
46:28 | Ok, what's the geometry say?
46:29 | The length of a line segment?
46:30 | Well, it's Pythagoras, right?
46:32 | I take the difference in the x-values, squared, the
46:34 | difference in the y-values, squared, add them up, take the
46:36 | square root of that.
46:38 | Notice what this says to do.
46:41 | It says if I want to get the length of a segment, going to
46:43 | pass in that instance, it says from that instance, get the
46:49 | start point, that's the thing I just found.
46:51 | And then from that start point, get the x-value.
46:56 | Same thing, from that instance, get the endpoint,
46:59 | from that end point get the x-value, square.
47:02 | Add the same thing to the y-values, squared, take the
47:05 | square root.
47:07 | Yes, ma'am?
47:07 | STUDENT: So are you entering a tuple in for start and end?
47:13 | PROFESSOR: No.
47:14 | I'm entering -- well, let's look at the
47:15 | example right down here.
47:17 | In fact, let me uncomment it so we can look at it.
47:20 | All right.
47:22 | I'm going to uncomment that.
47:24 | So notice what I'm going to do.
47:25 | I'm going to build, this case, a Cartesian point, I'm going
47:28 | to build a second Cartesian point, and my segment passes
47:32 | in those class instances.
47:35 | All right, they're not tuples, they're simply an instance
47:36 | with some structuring.
47:37 | And in fact if I go off and run this, OK, what I was
47:42 | printing here was s 1 dot length, and that's --
47:48 | What is it doing?
47:49 | S 1 is a segment.
47:51 | It has inside of it pointers to 2
47:53 | points which are instances.
47:55 | And when I call length on this, it takes that starting
47:59 | point, sends it the message saying give me your
48:01 | x-coordinate, takes the endpoint, says give me your
48:04 | x-coordinate, and add them together.
48:06 | Now, I prefaced this a few minutes ago about saying
48:08 | Professor Guttag wasn't going to like me.
48:10 | He doesn't like me generally, but that's between he and I.
48:12 | He beats me regularly at tennis, which is why
48:14 | I don't like him.
48:15 | Sorry, John.
48:16 | This is being taped, which is really good, isn't it?
48:18 | So why am I saying that?
48:19 | I said that if I was really hygienic, and you can now
48:23 | wonder about how often do I shower?
48:25 | If I was really hygienic.
48:27 | I would only ever access the values through a method.
48:32 | And I'm cheating here, right, because what am I doing?
48:35 | I'm taking advantage of the fact that start is going to be
48:39 | a point, and I'm just directly saying, give me your x-value.
48:43 | So I don't know don't, John, I would argue if I'd written
48:44 | this better, I would have had a method that returned the x-
48:47 | and the y- value, and it would be cleaner to go
48:49 | after it that way.
48:50 | This is nice shorthand, all right, but it's something that
48:53 | in fact I probably would want to do differently.
48:57 | Why would I want to do it differently?
48:59 | Imagine that I've written code like this,
49:02 | written a bunch of code.
49:04 | And I originally decided I was going to have as points, it's
49:06 | going to have internal values of an x and a y.
49:09 | And then somewhere along the line, I decide to store things
49:12 | in a different representation.
49:14 | If I had had a clean interface, that I had a
49:17 | specific method to get those values out, I wouldn't have to
49:20 | change anything.
49:22 | Other than that interface.
49:24 | But here, if I decide I'm going to store things not in x
49:26 | and y, but with some other set of names, for example, I've
49:30 | gotta go back into these pieces of code that use the
49:32 | points, and change them.
49:34 | So I've lost modularity.
49:35 | I'd really like to have that modularity that says, I'm only
49:38 | going to get access to the values, not by calling their
49:41 | names, but by calling some specific method to get access
49:44 | to their names.
49:46 | You could argue, well, x is in some sense inherently a
49:48 | method, but it's not nearly as clean as what I would like.
49:52 | And the last piece I want you to see here, and then I'll let
49:54 | you go is, notice now how that encapsulation, that binding
49:59 | things together has really helped me.
50:01 | Given the abstraction, the notion of a point as an
50:03 | instance with some values, I can now
50:05 | start building segments.
50:07 | And I could now extend that.
50:08 | I could have, you know, polygonal figures, that are a
50:10 | sequence of segments.
50:11 | And I would be able to simply bury away the details of how
50:14 | those other instances are created from how I want to use
50:17 | them by simply calling methods on the classes.
50:20 | We'll come back to this next time.
